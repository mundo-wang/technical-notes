`Redis`是基于内存的，如果服务器挂了，`Redis`的数据就全部丢失了。但是有些情况我们希望在服务重启之后，数据还恢复到原来的状态，就需要把数据持久化到磁盘了。

`Redis`采用了两种持久化方式：`RDB`和`AOF`。

### 1. `RDB`持久化

`RDB`持久化（`Redis DataBase`）是`Redis`的默认持久化方式。它通过将`Redis`某个时间点的数据以快照的形式保存在磁盘中的一个后缀为`.rdb`的文件中。这种文件通常以二进制格式存储。

`RDB`持久化的工作原理是`Redis`会`fork`一个子进程，由子进程负责将内存中的数据写入到临时文件中。当子进程完成对临时文件的写入后，`Redis`将旧的`RDB`文件替换为新的`RDB`文件。在这个过程中，`Redis`的主进程不会进行任何磁盘`I/O`操作，因此`RDB`持久化方式对`Redis`的性能影响较小。

`RDB`持久化的缺点是，如果`Redis`崩溃，最后一次`RDB`快照之后的数据会丢失。例如，如果每小时进行一次`RDB`操作，并且`Redis`在某个间隔周期的第`45`分钟崩溃，那么这`45`分钟内的数据变更都会丢失。

另一个缺点是`Redis`需要将整个数据集写入到磁盘中的临时文件中。尽管使用了子进程来完成这个操作，但在数据集较大的情况下，这个过程会消耗大量时间和资源，可能导致持久化期间`Redis`性能下降。

### 2. `AOF`持久化

`AOF`持久化（`Append-Only File`）不是`Redis`的默认持久化方式，需要手动配置开启。`AOF`采用的是日志持久化，以追加的方式记录每个增删改操作指令，记录到磁盘中一个`.aof`的文件中，这个文件保存的不是二进制格式，而是`Redis`命令的文本格式，但是它和我们手动操作`Redis`的命令格式还有些不同，如下所示：

```sh
*3
$3
SET
$5
myKey
$7
myValue

*2
$3
DEL
$5
myKey
```

`*3`代表指令有三个参数，`$3`代表参数的长度，其他同理。上面的文件就代表了这两条命令：

```sh
set myKey myValue
del myKey
```

当`Redis`崩溃并重启时，会重新执行`AOF`文件中的所有操作指令，从而恢复数据集的状态。由于`AOF`文件存储的是`Redis`命令的文本格式，所以`AOF`文件是人类可读的，也很容易进行备份和恢复。

`AOF`的缺点有以下两个：

1. 文件体积比`RDB`大很多，因为它记录了更多信息。
2. `AOF`执行了更频繁的磁盘`IO`操作，可能会占用计算机的很多资源。

为了解决`AOF`文件不断膨胀的问题，`Redis`引入了`AOF`重写机制。这是一项由后台异步执行的操作，其核心思路是不再依赖现有的`AOF`文件，而是通过遍历当前内存中的数据集，重新生成一份全新的`AOF`文件。

新的`AOF`文件只包含重建当前数据状态所需的最少写命令，去除了无效或重复的历史操作指令，从而大幅减小文件体积。在重写完成后，`Redis`会将旧的`AOF`文件原子地替换为新的`AOF`文件，至此完成整个重写过程。

这种机制不仅能有效减小`AOF`文件的大小，还能显著加快数据恢复速度，提高系统整体的可靠性与性能。

### 3. 如何选择

- 如果对数据的实时性要求不高，而更看重性能和简单性，可以选择使用`RDB`。它对性能的影响较小，但数据恢复的精确度较低。
- 如果对数据安全性要求较高，并且可以接受一定的性能开销，可以选择使用`AOF`。它通过记录每一个操作指令，能更准确地恢复数据，但会增加磁盘`I/O`负担。