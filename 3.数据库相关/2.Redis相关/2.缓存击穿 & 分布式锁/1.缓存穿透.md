缓存穿透是指请求的数据既不在缓存中，也不存在于数据库中，在高并发场景下可能导致大量请求直接落到数据库层，使访问压力急剧升高，缓存失去了应有的作用。造成这种情况的原因通常包括恶意请求，例如传入明显不存在的`id`（如`-1`或超大数值），或在高并发场景下访问已被删除的数据，最终引发对数据库的集中冲击。

## 一、解决缓存穿透的方法

1. 基础校验：在请求进入服务之前进行基础校验，例如参数校验、请求频率校验等，防止不合法的请求进入数据库。
2. 布隆过滤器：可以将数据库中所有合法数据的`id`写入`BloomFilter`，每次请求先访问`BloomFilter`进行判断。若某个`ID`在集合中不存在，`BloomFilter`能够迅速识别并将请求拦截，避免无效数据继续流入数据库。
3. 缓存空值：如果数据库查询结果为空，可以将指定`Key`设置`Value`为空值进行缓存，避免对数据库的重复查询。

## 二、布隆过滤器（`BloomFilter`）

布隆过滤器是一种用于快速判断元素是否属于某个集合的数据结构，其核心原理是借助位数组与多组哈希函数共同标记和检测元素的存在性，从而高效完成判断操作。

### 1. 数据结构概述

- 位数组：一个只包含`0`和`1`的数组，用于存储元素的存在信息，其长度是预先设定好的，通常初始化时所有位置都设置为`0`。
- 哈希函数：用来把输入元素映射到位数组中的不同位置。通常会使用多个相互独立的哈希函数，每个函数都会将输入元素转换为位数组中的一个索引位置。借助这些索引位置，可以在位数组中标记元素的存在状态。

### 2. 元素的加入与查询

#### 2.1 加入元素

当一个元素被加入布隆过滤器时，会通过多个哈希函数生成若干哈希值，每个哈希值对应位数组中一个位置，这些位置会被设置为`1`。

#### 2.2 查询元素

检查输入的元素是否存在时，会用相同的哈希函数生成多个哈希值，然后查看位数组中这些位置是否都为`1`。只要有任意一个位置为`0`，就可以确定该元素不存在；如果所有位置都是`1`，则表示该元素可能存在。

### 3. 误判问题

布隆过滤器可能出现误判，将不存在的元素误判为可能存在。比如，已有三个元素的哈希结果分别为`{2, 5, 7}`、`{3, 6, 8}`和`{4, 5, 9}`。如果要查找的元素的哈希结果为`{5, 6, 9}`，检查位数组时发现这些位置都是`1`，布隆过滤器就会判断该元素可能存在。实际上，这些位置被其他元素的哈希结果覆盖，因此产生了误判。

### 4. 使用方法

将数据库中所有数据的唯一标识符（如`id`）进行多次哈希，并在位数组中标记对应的位置。对于每个外部请求查询的`id`，执行相同的多次哈希并检查这些位置的值：

- 如果任意位置为`0`，则可以确定数据不在数据库中，直接拒绝请求。
- 如果所有位置都是`1`，则数据可能存在，此时再进行实际的缓存或数据库查询。

### 5. 局限性

- 误判：布隆过滤器只能判断“一定不存在”或“可能存在”。对于可能存在的元素，仍需进一步验证其实际存在性。
- 不可删除：元素一旦加入布隆过滤器，就无法删除。因为将对应位置置为`0`可能会影响其他元素的存在判断。
