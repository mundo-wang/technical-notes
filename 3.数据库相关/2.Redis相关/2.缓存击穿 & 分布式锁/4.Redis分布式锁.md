`Redis`分布式锁的主要作用是在分布式系统中防止多个节点同时执行同一段需要互斥的业务逻辑。

在单机应用中，通常使用编程语言自带的锁机制（例如`Go`语言的`sync.Mutex`）来控制并发访问。但在分布式系统中，多个服务实例部署在不同服务器上，不同实例之间的内存互不共享，这时本地锁就失效了。

假设有一个抢购商品的接口，业务逻辑是：首先读取商品库存，判断库存是否大于`0`；若大于`0`，则将库存减`1`并写回数据库。若没有使用分布式锁，多个服务实例的请求可能会同时读取到相同的库存值，最终卖出两件商品，但库存只减少`1`，从而导致超卖问题。

使用分布式锁后，只有成功获取锁的服务实例才能执行库存查询与扣减逻辑。扣减操作完成后，需要及时释放锁。其余服务实例在此期间会被阻塞，并持续尝试获取锁，从而确保同一时间内仅有一个服务实例能够操作库存数据，避免超卖问题的发生。

`Redis`实现分布式锁的基本步骤如下：首先，使用`SETNX`命令设置一个表示锁的键，当该键不存在时，设置成功并返回`1`，表示成功获取锁；若键已存在，则返回`0`，表示获取锁失败。为了防止锁因异常情况未被正常释放，通常会在设置锁的同时指定过期时间，使锁在超时后自动失效。业务处理完成后，再使用`DEL`命令删除该键，表示释放锁。

使用`Redis`分布式锁防止超卖的代码示例如下所示：

```go
func BuyProduct(c *gin.Context) {
	redisClient := redis.NewClient(&redis.Options{
		Addr: "localhost:6379",
	})
	ctx := c.Request.Context()
	productID := c.Query("product-id")
	lockKey := fmt.Sprintf("lock:product:%s", productID)
	requestID := uuid.NewString() // 随机值，用于标识锁的持有者
	timeout := 5 * time.Second    // 设定最大尝试获取锁的时间
	expire := 5 * time.Second     // 设定锁的自动过期时间，防止死锁
	start := time.Now()

	defer func() {
		// 释放锁前验证锁的持有者，防止误删
		val, _ := redisClient.Get(ctx, lockKey).Result()
		if val == requestID {
			redisClient.Del(ctx, lockKey)
		}
	}()

	for {
		ok, _ := redisClient.SetNX(ctx, lockKey, requestID, expire).Result()
		if ok {
			// 成功获取Redis分布式锁，执行减库存与下单的逻辑，此处省略
			c.JSON(200, gin.H{"message": "抢购成功"})
			return
		}
		if time.Since(start) > timeout {
			// 超过最大尝试获取锁的时间，还未获取到锁，返回错误信息
			c.JSON(429, gin.H{"error": "系统繁忙，请稍后再试"})
			return
		}
		time.Sleep(50 * time.Millisecond)
	}
}
```

除超卖问题外，`Redis`分布式锁还可以防止定时任务的重复执行、重复下单、重复支付等问题。