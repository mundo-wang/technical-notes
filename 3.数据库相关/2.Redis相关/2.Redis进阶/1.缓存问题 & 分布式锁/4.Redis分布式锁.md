`Redis`分布式锁的主要作用是在分布式系统中防止多个节点同时执行同一段需要互斥的业务逻辑。

在单机应用中，通常使用编程语言自带的锁机制（例如`Go`语言的`sync.Mutex`）来控制并发访问。但在分布式系统中，多个服务实例部署在不同服务器上，不同实例之间的内存互不共享，这时本地锁就失效了。

假设有一个抢购商品的接口，业务逻辑是：首先读取商品库存，判断库存是否大于`0`，若大于`0`，则将库存减`1`并写回数据库。若没有使用分布式锁，多个服务实例的请求可能会读取到相同的库存值，导致卖出两件商品，但库存只减少`1`，引发超卖问题。

在引入分布式锁后，只有成功获取锁的服务实例才允许执行库存查询与扣减操作，操作完成后立即释放锁。其他服务实例在锁被占用期间处于自旋等待状态，等待锁释放后再获取锁进行操作，避免超卖问题的出现。

`Redis`实现分布式锁的基本步骤如下：首先，使用`SETNX`命令设置一个表示锁的键，当该键不存在时，设置成功并返回`1`，表示成功获取锁；若键已存在，则返回`0`，表示获取锁失败。为了防止锁因异常情况未被正常释放，通常会在设置锁的同时指定过期时间，使锁在超时后自动失效。业务处理完成后，再使用`DEL`命令删除该键，表示释放锁。

使用`go-redis`库执行`SETNX`操作，其方法签名如下所示：

```go
func (c cmdable) SetNX(ctx context.Context, key string, value interface{}, expiration time.Duration) *BoolCmd
```

该方法返回的`*BoolCmd`类型提供了`Result`方法。调用后，第一个返回值`val`为布尔类型，用于表示操作是否成功。

使用`Redis`分布式锁防止超卖的代码示例如下所示：

```go
func BuyProduct(c *gin.Context) {
	redisClient := redis.NewClient(&redis.Options{
		Addr: "localhost:6379",
	})
	ctx := c.Request.Context()
	productID := c.Query("product-id")
	lockKey := fmt.Sprintf("lock:product:%s", productID)
	requestID := uuid.NewString() // 随机值，用于标识锁的持有者
	timeout := 5 * time.Second    // 设定最大尝试获取锁的时间
	expire := 5 * time.Second     // 设定锁的自动过期时间，防止死锁
	start := time.Now()

	defer func() {
		// 释放锁前验证锁的持有者，防止误删
		val, _ := redisClient.Get(ctx, lockKey).Result()
		if val == requestID {
			redisClient.Del(ctx, lockKey)
		}
	}()

	for {
		ok, _ := redisClient.SetNX(ctx, lockKey, requestID, expire).Result()
		if ok {
			// 成功获取Redis分布式锁，执行减库存与下单的逻辑，此处省略
			c.JSON(200, gin.H{"message": "抢购成功"})
			return
		}
		if time.Since(start) > timeout {
			// 超过最大尝试获取锁的时间，还未获取到锁，返回错误信息
			c.JSON(429, gin.H{"error": "系统繁忙，请稍后再试"})
			return
		}
		time.Sleep(50 * time.Millisecond)
	}
}
```

除超卖问题外，`Redis`分布式锁还可以防止定时任务的重复执行、重复下单、重复支付等问题。

`Redis`本身并未提供“线程阻塞直到锁可用”的原语，`SETNX`的返回结果仅用于表示当前获取锁操作是否成功。当获取锁失败时，客户端通常有两种处理策略：一是直接放弃获取锁，不执行对应业务操作，二是短暂休眠后再次尝试获取锁。

在前述超卖问题的解决方案中，采用的是内部短时间休眠并重试获取锁的方式；而在解决定时任务重复执行、重复下单、重复支付等场景下，一旦获取锁失败，则应直接放弃获取锁，不再执行对应的业务操作，以避免产生重复行为。

这也正是`Redis`分布式锁与`Go`语言内存锁（如`sync.Mutex`）之间的关键差异：前者天然支持“获取锁失败即放弃”的语义，调用方可以根据业务需要自行决定后续处理策略；而后者并不具备这种语义，一旦尝试加锁，调用方只能阻塞等待，直至成功获取锁。

下面列出两个成熟的实现`Redis`分布式锁的第三方库，可供选择：

```sh
go get github.com/go-redsync/redsync/v4
go get github.com/bsm/redislock
```

