### 1. 底层结构

在`Redis`中，字符串通过`SDS`（`Simple Dynamic String`）结构实现，类似于`Java`中的`String`类型。如果`value`保存的是整数，可以直接作为数字进行操作。其数据结构为：单个`key`对应单个`value`。

### 2. 适用场景

适用于缓存数据、计数器、分布式锁、有状态`token`保存等场景。

### 3. 操作命令

#### 3.1 新建键值对

普通设置，如果`key`已经存在，则会用新的`value`覆盖旧值：

```sh
set key value
```

如果`key`已经存在，则放弃设置，返回`0`，否则返回`1`：

```go
setnx key value
```

新建`key`的同时设置它的最大存活时间：

```sh
setex key seconds value
```

`setex`命令里的`seconds`参数单位是秒，必须为整数。若想设置毫秒级别，使用`psetex`代替`setex`。

批量设置字符串，如果某个`key`已经存在，使用对应`value`覆盖旧值：

```sh
mset k1 v1 k2 v2 k3 v3
```

批量设置字符串，如果某个`key`已经存在，全部放弃设置：

```
msetnx k1 v1 k2 v2 k3 v3
```

`string`类型的值可以为空字符串，例如执行`set key ""`时，会创建一个`string`类型键，并将其值设为空字符串。

#### 3.2 获取`value`

获取单个`value`：

```
get key
```

获取多个`key`对应的`value`：

```shell
mget k1 k2 k3 k4
```

#### 3.3 字符串追加

```shell
append key value
```

返回追加后的字符串长度。如果`key`不存在，新建`key`，并设置`value`值为输入的`value`。
#### 3.4 获取字符串数据长度

```shell
strlen key
```

#### 3.5 字符串数值处理

```shell
incr key          # 数值+1
decr key          # 数值-1
incrby key offset # 数值+offset
decrby key offset # 数值-offset
```

命令返回执行操作后对应的`value`值。若`key`不存在，会先创建该`key`并将`value`设为字符串`0`，随后再执行运算。若指定`key`对应的`value`不是整数，则会触发错误。

`Redis`的命令执行由单线程完成，而每条`Redis`指令都具备原子性。也就是说，当客户端向`Redis`发送一条指令时，该指令在服务器内部会一次性执行完毕，中途不会被其他客户端的指令打断，因此不会产生并发干扰。

基于这些特性，`Redis`能够实现强一致的并发控制，并有效降低应用层的锁竞争压力。以一万人同时抢一张优惠券为例，可在`Redis`中维护一个库存键`packet_key`，将其值设为`1`。所有抢券请求统一调用`DECR packet_key`指令，若返回值`>=0`，说明已成功抢到红包，可继续处理后续业务逻辑以更新数据库；若返回值`<0`，则表示库存已用尽，直接返回失败即可。

#### 3.6 闭区间获取子字符串

字符串下标可以从左往右从`0`开始，也可以从右往左从`-1`开始，二者等价：

```shell
getrange key startIndex endIndex
```

#### 3.7 用`value`覆盖字符串

```shell
setrange key startIndex value
```

从第`startIndex`个字符开始，用`value`覆盖字符串，返回覆盖后字符串的长度。
