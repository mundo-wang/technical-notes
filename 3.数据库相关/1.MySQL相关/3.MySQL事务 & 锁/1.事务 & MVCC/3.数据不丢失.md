### `MySQL`是如何保证数据不丢失的？

在默认存储引擎`InnoDB`下，`MySQL`为了保证数据不丢失，主要依赖于以下几个机制：

#### 1. 预写日志机制（`WAL`）

在`MySQL`中，`InnoDB`存储引擎采用预写式日志机制（`Write-Ahead Logging`），即先写日志再写数据。当你执行一条`INSERT`或`UPDATE`语句时，`InnoDB`并不会立即将修改后的数据写入磁盘页面，而是优先将变更记录写入重做日志（`Redo Log`）。只有当日志写入完成后，才会向客户端返回操作成功的响应。随后，后台线程会在合适的时机将实际的数据页刷新到磁盘。

这一机制确保了：即便发生崩溃，仍可通过`Redo Log`恢复那些尚未写入磁盘的数据，从而保证事务的持久性。

#### 2. 重做日志（`Redo Log`）

`Redo Log`是`InnoDB`层面最核心的机制之一，他会将数据连续地写入磁盘的物理块中，因此具有较高的写入效率。`Redo Log`由两部分组成：内存中的日志缓存（`Log Buffer`）和磁盘上的实际日志文件（`Redo Log File`）。

在事务提交时，`InnoDB`必须通过`fsync`将`Redo Log`刷盘，才能真正视为提交成功。若发生系统崩溃，`InnoDB`会利用`Redo Log`将数据恢复到最近一次成功提交的状态，从而确保数据的一致性和事务的持久性。

#### 3. 二进制日志（`Binlog`）

`Binlog`是记录在`MySQL Server`层的日志，与`InnoDB`的`Redo Log`不同，它属于逻辑日志，记录的是`SQL`语句或行级变更事件。`Binlog`的主要用途包括：数据复制（例如主从复制）以及数据恢复（例如使用`mysqlbinlog`工具恢复误删的数据）。需要注意的是，只有在事务提交之后，相关操作才会被写入`Binlog`。

当开启`Binlog`时，事务提交流程会遵循如下顺序：首先写入`Redo Log`，接着写入`Binlog`，两者都写入成功后，事务才被正式提交。这一过程被称为两阶段提交（`2PC`），用于保证`Redo Log`和`Binlog`的一致性。

#### 4. 崩溃恢复机制

当`MySQL`或操作系统崩溃后重启，`InnoDB`会做两件事：

- 用`Redo Log`重做已提交但尚未写入磁盘的数据；
- 用`Undo Log`回滚未提交的事务。

这两个机制保证了数据库恢复时不会丢失已提交的数据，也不会留下未提交的数据。

#### 5. 刷盘策略

`innodb_flush_log_at_trx_commit`参数控制`Redo Log`的刷盘行为，影响数据安全性：

| 参数值 | 行为说明                                  | 安全性 | 性能 |
| ------ | ----------------------------------------- | ------ | ---- |
| `1`    | 每次提交都`fsync`到磁盘                   | 最安全 | 慢   |
| `2`    | 每次提交写入`Log Buffer`，每秒`fsync`一次 | 较安全 | 快   |
| `0`    | 每次提交只写`Log Buffer`，不刷盘          | 不安全 | 快   |

默认是`1`，即每次事务提交都同步写磁盘，这是保证事务不丢失的关键配置之一。