### `MySQL`是如何保证数据不丢失的？

在默认存储引擎`InnoDB`下，`MySQL`为了保证数据不丢失，主要依赖于以下几个机制：

#### 1. 预写日志机制（`WAL`）

在`MySQL`中，`InnoDB`存储引擎采用预写式日志机制（`Write-Ahead Logging`），即先写日志再写数据。当你执行一条`INSERT`或`UPDATE`语句时，`InnoDB`并不会立即将修改后的数据写入磁盘，而是优先将变更记录写入重做日志（`Redo Log`）。当重做日志写入完成后，就会向客户端返回操作成功的响应。随后，后台线程会在合适的时机将实际的数据页刷新到磁盘。

这一机制确保了：即便发生崩溃，仍可通过`Redo Log`恢复那些尚未写入磁盘的数据，从而保证事务的持久性。

#### 2. 重做日志（`Redo Log`）

`Redo Log`是`InnoDB`层面最核心的机制之一，它通过将数据连续写入磁盘上的物理块，实现了较高的写入效率。`Redo Log`由两个部分组成：内存中的日志缓存（`Log Buffer`）和磁盘上的实际日志文件（`Redo Log File`）。作为一种物理日志，`Redo Log`记录的是数据库中数据页的物理变更操作，例如“在偏移量为`X`的位置写入值`Y`”。

在事务提交时，`InnoDB`会先将`Redo Log`从`Log Buffer`刷新到`Redo Log File`，并通过`fsync`将其持久化到磁盘，只有在日志成功落盘后，事务才被视为真正提交。需要注意的是，此时数据页本身可能仍未写入磁盘，但由于`Redo Log`已被持久化，即使系统发生崩溃，也可以通过`Redo Log`将数据恢复到最近一次成功提交的状态，从而确保数据的一致性与事务的持久性。

#### 3. 二进制日志（`Binlog`）

`Binlog`是记录在`MySQL Server`层的日志，与`InnoDB`的`Redo Log`不同，它属于逻辑日志。根据`binlog_format`的不同，`Binlog`记录的内容可能是执行的增、删、改操作的`SQL`语句（在`STATEMENT`模式下），也可能是数据变更的行记录（在`ROW`模式下）。

`Binlog`的主要用途包括：数据复制（例如主从复制）以及数据恢复（例如使用`mysqlbinlog`工具恢复误删的数据）。需要注意的是，只有在事务提交之后，相关操作才会被写入`Binlog`。

当开启`Binlog`时，事务提交流程会遵循如下顺序：首先写入`Redo Log`，接着写入`Binlog`，两者都写入成功后，事务才被正式提交。这一过程被称为两阶段提交（`2PC`），用于保证`Redo Log`和`Binlog`的一致性。

#### 4. 崩溃恢复机制

当`MySQL`或操作系统崩溃后重启，`InnoDB`会做两件事：

- 用`Redo Log`重做已提交但尚未写入磁盘的数据；
- 用`Undo Log`回滚未提交的事务。

这两个机制保证了数据库恢复时不会丢失已提交的数据，也不会留下未提交的数据。

#### 5. 刷盘策略

`innodb_flush_log_at_trx_commit`参数控制`Redo Log`的刷盘行为，影响数据安全性：

| 参数值 | 行为说明                                  | 安全性 | 性能 |
| ------ | ----------------------------------------- | ------ | ---- |
| `1`    | 每次提交都`fsync`到磁盘                   | 最安全 | 慢   |
| `2`    | 每次提交写入`Log Buffer`，每秒`fsync`一次 | 较安全 | 快   |
| `0`    | 每次提交只写`Log Buffer`，不刷盘          | 不安全 | 快   |

默认参数值是`1`，即每次事务提交都同步写磁盘，这是保证事务不丢失的关键配置之一。