### 1. 复合索引不满足“最左前缀法则”

在使用复合索引时，查询条件必须从索引的最左前列开始，且不能跳过中间的索引列。以复合索引（`A`,`B`,`C`）为例：若查询条件包含`A`列和`C`列，则只有`A`列能够命中索引；若查询条件仅包含`B`列和`C`列，则由于缺失最左前列`A`，索引无法生效。

### 2. 复合索引的范围查询，部分索引失效

假设有复合索引（`A`,`B`,`C`），那么在下面的查询中只有`A`列能够命中索引：

```sql
SELECT * FROM tbl_name WHERE A = 1 AND B > 5 AND C = 3;
```

> 如果`A`、`B`、`C`是三个独立的单列索引，那么不存在范围查询导致索引失效这个问题，但是在同一条查询里，三个独立的单列索引无法同时都被有效利用，`MySQL`在一次表访问中通常只会选择一个索引作为主访问路径。

### 3. 索引列上的运算操作导致索引失效

在索引列上进行运算操作，索引会失效：

```sql
SELECT * FROM user WHERE age * 2 = 40;
```

### 4. 字符串不加单引号导致索引失效

字符串不加单引号，会造成索引失效。正确写法如下：

```sql
SELECT * FROM users WHERE username = 'admin';
```

### 5. 在索引列上执行函数导致索引失效

对索引列使用函数，如`DATE(created_at)`、`UPPER(name)`、`YEAR(order_time)`等，会导致索引失效。例如：

```sql
SELECT * FROM orders WHERE DATE(created_at) = '2024-01-01';
```

原因在于`MySQL`的`B-Tree`索引是基于列的原始值有序存储的，而不是基于“函数计算后的结果”。当`WHERE`条件中对索引列施加函数时，索引中存储的有序值无法直接用于比较，优化器通常无法将条件下推到索引层。

`WHERE`子句中不能使用聚合函数；当在`HAVING`子句中的字段上执行聚合函数时，索引会失效。但这并不是因为聚合函数本身导致索引失效，而是因为`HAVING`中的条件作用于聚合之后的结果集，而非原始表行数据，索引无法直接应用于聚合结果。

实际上，`HAVING`条件无论是否涉及聚合函数，通常都无法利用索引提高结果过滤效率。

### 6. `OR`分割的条件导致索引失效

使用`OR`连接的查询条件中，如果`OR`前的列存在索引，而`OR`后的列不存在索引，则整体查询将无法使用索引。

可以使用`UNION`来代替`OR`，以避免索引失效：

```sql
SELECT * FROM users WHERE age = 30
UNION
SELECT * FROM users WHERE name = 'John';
```

### 7. 以`%`开头的`LIKE`模糊查询导致索引失效

对于`B+`树的索引来说，`%`代表任意字符，无法利用`B+`树的有序结构快速定位满足条件的数据，只能通过全表扫描来进行模糊查询。例如，`LIKE '%科技'`会导致索引失效，而`LIKE '科技%'`不会失效。

### 8. `MySQL`自动评估导致索引不创建或不使用

在创建索引时，如果`MySQL`评估使用索引比全表扫描更慢，则不会创建该索引，并且在查询时也不会走索引。

例如，假设有一个名为`orders`的表，其中有一个`status`列，表示订单的状态，可能取值为`pending`、`processing`、`completed`等。如果这个表的数据量不大，而且几乎所有订单的状态都是`completed`，那么在这种情况下创建`status`列的索引不会提高查询效率，反而会增加额外的开销，查询该列时不会走索引。

### 9. `IS NULL`和`IS NOT NULL`有时索引失效

`MySQL`在处理`IS NULL`或`IS NOT NULL`条件时，是否使用索引取决于优化器的成本评估。

当字段中`NULL`或非`NULL`值占比过高、索引选择性低时，走索引需要扫描大量索引记录并频繁回表，其随机`I/O`和`CPU`开销往往高于一次顺序全表扫描，因此优化器通常会放弃索引，选择全表扫描。具体而言：

- 当`NULL`占比较高时，使用`IS NULL`进行查询通常不会走索引
- 当`NULL`占比较低时，使用`IS NOT NULL`进行查询通常不会走索引

### 10. `IN`走索引，`NOT IN`索引失效

使用`IN`时，数据库可以快速定位到索引中包含`IN`列表的值的位置，提高查询性能。而使用`NOT IN`时，数据库无法使用索引，只能全表扫描，导致索引失效。可以使用`NOT EXISTS`或者`LEFT JOIN`改写查询语句，利用索引。例如下面的`SQL`语句：

```sql
SELECT * FROM t_student WHERE name NOT IN ('value1', 'value2', ...);
```

可以改写为使用`NOT EXISTS`子查询的形式：

```sql
SELECT * FROM t_student t1 WHERE NOT EXISTS (SELECT 1 FROM t_student t2 WHERE t2.name IN ('value1', 'value2', ...) AND t1.name = t2.name);
```

或者使用`LEFT JOIN`的形式：

```sql
SELECT t1.* FROM t_student t1 LEFT JOIN t_student t2 ON t2.name IN ('value1', 'value2', ...) AND t1.name = t2.name WHERE t2.name IS NULL;
```