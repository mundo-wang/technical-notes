在业务系统中，有些字段的取值是有限且可枚举的，例如证件类型、学历、国籍等。如果将这些枚举值直接存储在业务表中，后期维护会变得非常困难。以职员表为例，若直接存储枚举值，如下所示：

| `name` | `gender` | `id_type` | `education` | `country` |
| ------ | -------- | --------- | ----------- | --------- |
| 张三   | 男       | 身份证    | 本科        | 中国      |
| 李四   | 女       | 身份证    | 本科        | 中国      |
| …      | …        | …         | …           | …         |

当后续需要将“身份证”修改为“居民身份证”时，如果直接更新业务表中所有匹配的数据，不仅成本高，而且极易出错。为了解决这一问题，可以引入字典表，通过建立标签与代号的对应关系，实现前端展示标签、后端存储代号。

例如我们新增一个证件类型字典表，命名为`sys_dict_id_type`：

| `dict_label` | `dict_value` |
| ----- | ---------- |
| 身份证 | `ID_CARD` |
| 护照 | `PASSPORT` |

这样，职员表的修改如下：

| `name` | `gender` | `id_type` | `education` | `country` |
| ---- | ---- | -------- | ---- | ---- |
| 张三 | 男   | `ID_CARD` | 本科 | 中国 |
| 李四 | 女   | `PASSPORT` | 本科 | 中国 |
| …    | …    | …        | …    | …    |

这样一来，若需要修改展示的枚举值，只需更新字典表的`dict_label`字段，例如将“身份证”调整为“居民身份证”，无需对业务表进行任何变更。通过对所有可枚举字段进行集中管理，可以有效降低维护成本并减少出错风险。

为了避免给每个类型都新建一个字典表，我们可以设计一张通用字典表`sys_dict`，并增加`dict_type`字段用于分类：


| `dict_type` | `dict_label` | `dict_value`    |
| ----------- | ------------ | --------------- |
| `id_type`   | 身份证          | `ID_CARD`       |
| `id_type`   | 护照           | `PASSPORT`      |
| `country`   | 中国           | `CHINA`         |
| `country`   | 美国           | `AMERICA`       |
| `education` | 本科           | `UNDERGRADUATE` |
| `education` | 硕士           | `MASTER`        |

`dict_value`是业务表中实际存储的内容，一般情况下不应随意修改。若`dict_type`发生变更，应及时与前端保持同步。

上述内容为一个最基础的字典表的雏形。我们的字典表采用若依框架的设计思路，将字典定义与字典数据分离存储，分别使用`sys_dict_type`和`sys_dict_item`两张表来实现。以下为这两张表的建表语句：

```sql
CREATE TABLE `sys_dict` (
  `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '主键',
  `dict_name` VARCHAR(100) NOT NULL DEFAULT '' COMMENT '字典名称',
  `dict_type` VARCHAR(100) NOT NULL COMMENT '字典类型，与sys_dict_item.dict_type关联',
  `status` TINYINT NOT NULL DEFAULT 0 COMMENT '状态 0=禁用 1=启用',
  `description` VARCHAR(500) NOT NULL DEFAULT '' COMMENT '描述信息',
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY uk_dict_type (`dict_type`)
) ENGINE=INNODB DEFAULT CHARSET=utf8mb4 COMMENT='字典主表';

CREATE TABLE `sys_dict_item` (
  `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '主键',
  `dict_type` VARCHAR(100) NOT NULL COMMENT '字典类型，与sys_dict.dict_type关联',
  `dict_label` VARCHAR(100) NOT NULL DEFAULT '' COMMENT '字典标签，用于前端展示',
  `dict_value` VARCHAR(100) NOT NULL DEFAULT '' COMMENT '字典值，与标签配对，用于后端存储',
  `sort` INT NOT NULL DEFAULT 0 COMMENT '字典排序，数字越小越靠前',
  `default_flag` TINYINT NOT NULL DEFAULT 0 COMMENT '是否默认 0=否 1=是',
  `status` TINYINT NOT NULL DEFAULT 0 COMMENT '状态 0=禁用 1=启用',
  `description` VARCHAR(500) NOT NULL DEFAULT '' COMMENT '描述信息',
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY uk_dict_item_type_value (`dict_type`,`dict_value`)
) ENGINE=INNODB DEFAULT CHARSET=utf8mb4 COMMENT='字典数据表';
```

上述字典表数据示例，插入到我们定义的字典表中的语句如下所示：

```sql
INSERT INTO `sys_dict` (`dict_name`, `dict_type`, `status`)
VALUES
  ('证件类型', 'id_type', 1),
  ('国家', 'country', 1),
  ('学历', 'education', 1);

INSERT INTO `sys_dict_item` (`dict_type`, `dict_label`, `dict_value`, `sort`, `default_flag`, `status`)
VALUES
  ('id_type', '身份证', 'ID_CARD', 1, 1, 1),
  ('id_type', '护照', 'PASSPORT', 2, 0, 1),
  ('country', '中国', 'CHINA', 1, 1, 1),
  ('country', '美国', 'AMERICA', 2, 0, 1),
  ('education', '本科', 'UNDERGRADUATE', 1, 1, 1),
  ('education', '硕士', 'MASTER', 2, 0, 1);
```

字典表的数据可以通过手动编写`SQL`语句录入，也可以提供增删改查接口，由前端新增一个仅限超级管理员访问的管理界面，统一完成数据的增删改查操作。推荐采用后者方式。

在业务中使用字典项的流程如下：这类枚举类型通常出现在前端的下拉框、单选框、复选框等组件中。前端会保存对应的`dict_type`值，并向后端请求具体的字典项数据，后端通常会按照`sort`字段从小到大排序后返回字典项的`dict_label`和`dict_value`。

其中，用户界面展示的是`dict_label`，而前端向后端发送请求时传递的是`dict_value`，数据库中保存的也是`dict_value`。在后续查询并返回前端展示时，后端需要根据`dict_value`与对应的`dict_type`，从字典表中获取对应的`dict_label`，再返回给前端。亦或者，也可以直接返回`dict_value`给前端，由前端结合已有的字典映射关系，展示对应的`dict_label`。
