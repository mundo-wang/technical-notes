推荐使用`MinIO`官方提供的`Go SDK`来访问`MinIO`服务：

```sh
go get github.com/minio/minio-go/v7
```

首先我们先把创建`MinIO`客户端所需的配置信息写到配置文件：

```yaml
minio:
  endpoint: "123.60.188.152:9000"
  accessKey: "5lIUJj5y6wbQT2ydr238"
  secretKey: "Jqom6heF0f6CQVpKhQdX3sJEyegdTJ7iba33jSMo"
  bucket: "mundo-bucket"
  useSSL: false  # 表示是否通过HTTPS而不是HTTP与服务端通信
```

接下来使用`viper`库，将配置文件中的信息反序列化并映射到结构体对象中，结构如下：

```go
type MinioConfig struct {
	AccessKey string `mapstructure:"accessKey"`
	SecretKey string `mapstructure:"secretKey"`
	Bucket    string `mapstructure:"bucket"`
	Endpoint  string `mapstructure:"endpoint"`
	UseSSL    bool   `mapstructure:"useSSL"`
}
```

具体的反序列化映射代码此处不作展示。

接下来，在`utils`包中编写如下代码，用于实现`MinIO`客户端对象的单例创建，并完成`Bucket`的初始化操作：

```go
var (
	minioClient *minio.Client
)

func NewMinioClient(bucketName string) (*minio.Client, error) {
	if minioClient == nil {
		var err error
		minioClient, err = minio.New(conf.Config.Minio.Endpoint, &minio.Options{
			Creds:  credentials.NewStaticV4(conf.Config.Minio.AccessKey, conf.Config.Minio.SecretKey, ""),
			Secure: conf.Config.Minio.UseSSL,
		})
		if err != nil {
			wlog.Error("call minio.New failed").Err(err).Log()
			return nil, err
		}
	}
	exists, err := minioClient.BucketExists(context.Background(), bucketName)
	if err != nil {
		wlog.Error("call minioClient.BucketExists failed").Err(err).Log()
		return nil, err
	}
	if !exists {
		err = minioClient.MakeBucket(context.Background(), bucketName, minio.MakeBucketOptions{})
		if err != nil {
			wlog.Error("call minioClient.MakeBucket failed").Err(err).Log()
			return nil, err
		}
	}
	return minioClient, nil
}
```

这一步仅完成了对`bucketName`的存在性判断和创建操作，并未将其与返回的`*minio.Client`对象进行绑定。

其中`credentials.NewStaticV4`的方法签名如下所示：

```go
func NewStaticV4(id, secret, token string) *Credentials
```

这里的第三个参数`token`表示临时安全令牌，通常在`AWS STS`中获取。由于我们使用的是长期固定密钥，因此此处填入空字符串。

调用方可以通过以下代码获取`MinIO`的客户端对象：

```go
minioClient, err := utils.NewMinioClient(utils.Config.Minio.Bucket)
```
