#### 1. 上传对象

`MinIO`提供了两种主要的对象上传方式：`PutObject`和`FPutObject`。其中，`PutObject`适用于将数据流（`io.Reader`）中的内容上传至`MinIO`，而`FPutObject`则用于直接将本地文件路径下的文件上传至`MinIO`。

`PutObject`方法的方法签名如下所示：

```go
func (c *Client) PutObject(ctx context.Context, bucketName, objectName string, reader io.Reader, 
	size int64, opts PutObjectOptions) (info UploadInfo, err error)
```

其中，`size`表示上传文件的大小，单位为字节。由于`PutObject`采用的是单次直接上传方式，即将整个文件作为一个对象一次性上传，因此`MinIO`或`S3`服务端需要提前知道请求体的总字节数。返回值`UploadInfo`保存上传对象的部分元数据信息。

在`Gin`的文件上传流程中，包括以下几个步骤：客户端上传文件，服务端生成自定义文件名，将文件保存到本地路径，返回该文件名给客户端。如果使用`MinIO`，只需将“保存到本地路径”这一步骤替换为“保存到`MinIO`”即可，其余流程保持不变：

```go
func PutFile(c *gin.Context) {
	file, _ := c.FormFile("my-file")
	// 获取文件后缀，并生成唯一对象名（该文件对应的MinIO的Key）
	ext := filepath.Ext(file.Filename)
	rnd := rand.New(rand.NewSource(time.Now().UnixNano()))
	objectName := fmt.Sprintf("images/%d%05d%s", time.Now().UnixMilli(), rnd.Intn(100000), ext)
	// 打开上传的文件，获取文件流，其中File是io.Reader的子接口
	srcFile, _ := file.Open()
	defer srcFile.Close()
	// 获取minio客户端对象
	bucketName := utils.Config.Minio.Bucket
	minioClient, _ := utils.NewMinioClient(bucketName)
	// 上传文件到MinIO
	fmt.Println(file.Header.Get("Content-Type"))
	_, _ = minioClient.PutObject(c.Request.Context(), bucketName, objectName,
		srcFile, file.Size, minio.PutObjectOptions{
			ContentType: file.Header.Get("Content-Type"), // 选填项，默认为application/octet-stream
		})
	// 返回成功响应，以及对象名
	wresp.OK(c, objectName)
}
```

同样地，我们也可以实现多文件上传，只需在`Gin`接口接收多个文件后进行遍历上传即可。此处不再赘述。

`FPutObject`方法的方法签名如下所示：

```go
func (c *Client) FPutObject(ctx context.Context, bucketName, objectName, filePath string,
	opts PutObjectOptions) (info UploadInfo, err error)
```

使用`FPutObject`，客户端需要传入本地文件的相对路径或绝对路径，代码如下：

```go
func FPutFile(c *gin.Context) {
	filePath := c.Query("file-path") // 可为相对路径或绝对路径
	// 从文件名中提取扩展名，并尝试根据扩展名获取Content-Type
	ext := filepath.Ext(filePath)
	contentType := mime.TypeByExtension(ext)
	rnd := rand.New(rand.NewSource(time.Now().UnixNano()))
	objectName := fmt.Sprintf("images/%d%05d%s", time.Now().UnixMilli(), rnd.Intn(100000), ext)
	bucketName := utils.Config.Minio.Bucket
	minioClient, _ := utils.NewMinioClient(bucketName)
	_, _ = minioClient.FPutObject(c.Request.Context(), bucketName, objectName,
		filePath, minio.PutObjectOptions{
			ContentType: contentType,
		})
	wresp.OK(c, objectName)
}
```

这种方式要求待上传文件必须已经存在于本地服务器，或者用户先将文件上传到本地服务器，再由本地服务器上传至`MinIO`。

> 需要注意：从文件名中提取扩展名，再获取`Content-Type`的方式是不安全的，因为客户端可以伪造文件名后缀。

在`minio-go`源码中，`PutObject`和`FPutObject`会调用内部逻辑来判断上传方式：

- 对于`PutObject`方法：
  - 如果对象大小小于`16MiB`，则采用单次`PUT`上传；
  - 如果对象大小大于`16MiB`，则自动进行`multipart`上传，以分片大小至少为`16MiB`；
  - 如果传入的大小为`-1`（未知尺寸），则使用`multipart`模式持续上传至`EOF`，最大支持`5TiB`。
- 对于`FPutObject`方法（从本地文件上传）：
  - 如果文件大小小于`128MiB`，则采用单次`PUT`上传；
  - 如果文件大小大于`128MiB`，则自动进行`multipart`上传，分片大小不小于`128MiB`，最大支持`5TiB`。

#### 2. 读取/下载对象

读取指定对象，使用到`GetObject`方法，需要客户端传入对应`MinIO`文件的`Key`，代码如下所示：

```go
func GetFile(c *gin.Context) {
	// 获取请求参数中的对象名
	objectName := c.Query("object-name")
	bucketName := utils.Config.Minio.Bucket
	minioClient, _ := utils.NewMinioClient(bucketName)
    // 调用GetObject时，即使objectName不存在，也不会返回error
	object, _ := minioClient.GetObject(c.Request.Context(),
		bucketName, objectName, minio.GetObjectOptions{})
	defer object.Close()
	// 读取对象为字节数组
	data, _ := io.ReadAll(object)
	// 从对象名中提取扩展名，并尝试根据扩展名获取Content-Type
	ext := filepath.Ext(objectName)
	contentType := mime.TypeByExtension(ext)
	if contentType == "" {
		contentType = "application/octet-stream"
	}
	c.Data(http.StatusOK, contentType, data)
}
```

如果担心一次性`io.ReadAll`加载大文件可能导致内存问题，也可以使用流式返回方式：

```go
c.Header("Content-Type", contentType)
// 直接将对象流拷贝到响应体中
_, _ = io.Copy(c.Writer, object)
```

如果希望在访问上述接口后直接触发文件下载，需要使浏览器触发下载行为。在调用`c.Data`之前，添加以下代码：

```go
c.Header("Content-Type", "application/octet-stream")
c.Header("Content-Disposition", fmt.Sprintf("attachment; filename=%s", path.Base(objectName)))
```

当然，文件下载的触发过程也可以由前端完成，后端只需返回文件名即可：

```go
c.Header("File-Name", path.Base(objectName))
```

如果添加了文件下载逻辑，那么获取文件接口的函数名应该改为`DownloadFile`，更符合业务含义。

#### 3. 删除对象

删除对象需客户端传入要删除的`MinIO`文件对应的`Key`，代码如下所示：

```go
func DeleteFile(c *gin.Context) {
	objectName := c.Query("object-name")
	bucketName := utils.Config.Minio.Bucket
	minioClient, _ := utils.NewMinioClient(bucketName)
	// 删除对象为幂等操作，即使objectName不存在，也不会返回error
	_ = minioClient.RemoveObject(c.Request.Context(), bucketName,
		objectName, minio.RemoveObjectOptions{})
	wresp.OK(c, fmt.Sprintf("文件 %s 已删除", objectName))
}
```

如果想一次删除多个对象，可以使用`RemoveObject`方法，其方法签名如下：

```go
func (c *Client) RemoveObjects(ctx context.Context, bucketName string,
	objectsCh <-chan ObjectInfo, opts RemoveObjectsOptions) <-chan RemoveObjectError
```

其中`RemoveObjectError`的结构如下所示：

```go
type RemoveObjectError struct {
	ObjectName string
	VersionID  string
	Err        error
}
```

这里我们采用请求体传参的方式，代码如下：

```go
type Request struct {
	ObjectNames []string `json:"objectNames"`
}

func DeleteFiles(c *gin.Context) {
	req := &Request{}
	_ = c.ShouldBindJSON(req)
	bucketName := utils.Config.Minio.Bucket
	minioClient, _ := utils.NewMinioClient(bucketName)
	objectCh := make(chan minio.ObjectInfo)
	// 启动协程异步推入对象，与RemoveObjects并发进行，防止堵塞
	go func() {
        // 协程结束后关闭objectCh，表示该通道不再接受新的写入操作，但仍可以正常读取其中已存在的数据
		defer close(objectCh)
		for _, objectNames := range req.ObjectNames {
			objectCh <- minio.ObjectInfo{Key: objectNames}
		}
	}()
	// 收集失败信息
	var failed []string
	errorChan := minioClient.RemoveObjects(c.Request.Context(), bucketName,
		objectCh, minio.RemoveObjectsOptions{})
	for err := range errorChan {
		if err.Err != nil {
			failed = append(failed, err.ObjectName)
		}
	}
	if len(failed) > 0 {
		wresp.Fail(c, http.StatusInternalServerError, fmt.Sprintf("部分文件删除失败：%v", failed))
		return
	}
	wresp.OK(c, fmt.Sprintf("成功删除%d个文件", len(req.ObjectNames)))
}
```

请求体示例如下所示：

```go
{
  "objectNames": [
    "images/175394687416322848.png",
    "images/175394713650039849.png",
    "images/175394929631576627.png"
  ]
}
```

#### 4. 复制对象

复制对象使用到`CopyObject`方法，其方法签名如下：

```go
func (c *Client) CopyObject(ctx context.Context, dst CopyDestOptions,
	src CopySrcOptions) (UploadInfo, error)
```

复制对象需要指定源对象的`Key`以及目标对象的`Key`，代码如下所示：

```go
func CopyFile(c *gin.Context) {
	// 获取源对象和目标对象名称
	srcObjectName := c.Query("src-object-name")
	dstObjectName := c.Query("dst-object-name")
	bucketName := utils.Config.Minio.Bucket
	minioClient, _ := utils.NewMinioClient(bucketName)
	// 构建源对象的配置信息
	src := minio.CopySrcOptions{
		Bucket: bucketName,
		Object: srcObjectName,
	}
	// 构建目标对象的配置信息
	dst := minio.CopyDestOptions{
		Bucket: bucketName,
		Object: dstObjectName,
	}
	// 执行复制操作
	_, _ = minioClient.CopyObject(c.Request.Context(), dst, src)
	wresp.OK(c, fmt.Sprintf("已将对象从%s复制为%s", srcObjectName, dstObjectName))
}
```

使用`CopyObject`执行复制操作时，如果`srcObjectName`在`MinIO`不存在，会返回`error`：`The specified key does not exist`。

#### 5. 获取对象`Key`列表

获取对象`Key`列表时，可以通过前缀进行筛选，使用到`ListObjects`方法，其方法签名如下：

```go
func (c *Client) ListObjects(ctx context.Context, bucketName string,
	opts ListObjectsOptions) <-chan ObjectInfo
```

可以看到该方法返回一个只读通道，我们可以使用`for...range`进行遍历，代码如下：

```go
func ListFilesName(c *gin.Context) {
	// 获取筛选对象Key的前缀，可为空，空则列出所有对象
	prefix := c.Query("prefix")
	bucketName := utils.Config.Minio.Bucket
	minioClient, _ := utils.NewMinioClient(bucketName)
	// 构建对象列举配置项
	opts := minio.ListObjectsOptions{
		Prefix:    prefix,
		Recursive: true, // 设置为true以递归列出所有子目录下的对象
	}
	var objectKeys []string
	for object := range minioClient.ListObjects(c.Request.Context(), bucketName, opts) {
		objectKeys = append(objectKeys, object.Key)
	}
	wresp.OK(c, objectKeys)
}
```

在`MinIO`的基础知识部分我们提到，`Object`的`Key`本质上是扁平的。但我们可以通过在`Key`中使用`/`来模拟类似目录的层级结构。因此，常见的前缀通常采用以`/`结尾的“类目录结构”，比如前面上传对象的示例代码中，我们为所有的`Key`指定了`images/`这个前缀，那么此时传递的`prefix`就可以是`images/`，这样就可以获取所有指定路径下的对象。

#### 6. 获取对象元数据

获取对象元数据，使用到`StatObject`方法，其方法签名如下：

```go
func (c *Client) StatObject(ctx context.Context, bucketName,
	objectName string, opts StatObjectOptions) (ObjectInfo, error)
```

可以看到，该方法的返回值与`ListObjects`的返回值、`RemoveObjects`的入参一致，均为`ObjectInfo`对象。相比`UploadInfo`对象，`ObjectInfo`提供了更为丰富的对象元数据信息。我们从中提取了一些关键字段用于返回，相关代码如下所示：

```go
func GetFileStat(c *gin.Context) {
	objectName := c.Query("object-name")
	bucketName := utils.Config.Minio.Bucket
	minioClient, _ := utils.NewMinioClient(bucketName)
	// 获取对象的元信息
	info, _ := minioClient.StatObject(c.Request.Context(), bucketName, objectName, minio.StatObjectOptions{})
	// 收集info中重要数据，构造响应数据
	meta := map[string]interface{}{
		"object_name":   info.Key,
		"size":          info.Size,
		"etag":          info.ETag,
		"content_type":  info.ContentType,
		"last_modified": info.LastModified.Format(time.DateTime),
		"user_metadata": info.UserMetadata, // 用户自定义元数据
	}
	wresp.OK(c, meta)
}
```

如果访问的对象`Key`不存在，`StatObject`会返回`error`：`The specified key does not exist`。
