#### 1. 上传对象

`MinIO`提供了两种主要的对象上传方式：`PutObject`和`FPutObject`。其中，`PutObject`适用于将数据流（`io.Reader`）中的内容上传至`MinIO`，而`FPutObject`则用于直接将本地文件路径下的文件上传至`MinIO`。

`PutObject`方法的方法签名如下所示：

```go
func (c *Client) PutObject(ctx context.Context, bucketName, objectName string, reader io.Reader, size int64,
	opts PutObjectOptions) (info UploadInfo, err error)
```

其中，`size`表示上传文件的大小，单位为字节。由于`PutObject`采用的是单次直接上传方式，即将整个文件作为一个对象一次性上传，因此`MinIO`或`S3`服务端需要提前知道请求体的总字节数。返回值`UploadInfo`保存上传对象的部分元数据信息。

在`Gin`的文件上传流程中，包括以下几个步骤：客户端上传文件，服务端生成自定义文件名，将文件保存到本地路径，返回该文件名给客户端。如果使用`MinIO`，只需将“保存到本地路径”这一步骤替换为“保存到`MinIO`”即可，其余流程保持不变：

```go
func PutFile(c *gin.Context) {
	file, _ := c.FormFile("my-file")
	// 获取文件后缀，并生成唯一对象名（该文件对应的MinIO的Key）
	ext := filepath.Ext(file.Filename)
	rnd := rand.New(rand.NewSource(time.Now().UnixNano()))
	objectName := fmt.Sprintf("images/%d%05d%s", time.Now().UnixMilli(), rnd.Intn(100000), ext)
	// 打开上传的文件，获取文件流，其中File是io.Reader的子接口
	srcFile, _ := file.Open()
	defer srcFile.Close()
	// 获取minio客户端对象
	bucketName := utils.Config.Minio.Bucket
	minioClient, _ := utils.NewMinioClient(bucketName)
	// 上传文件到MinIO
	fmt.Println(file.Header.Get("Content-Type"))
	_, _ = minioClient.PutObject(c.Request.Context(), bucketName, objectName,
		srcFile, file.Size, minio.PutObjectOptions{
			ContentType: file.Header.Get("Content-Type"), // 选填项，默认为application/octet-stream
		})
	// 返回成功响应，以及对象名
	wresp.OK(c, objectName)
}
```

同样地，我们也可以实现多文件上传，只需在接收多个文件后进行遍历上传即可。此处不再赘述。

`FPutObject`方法的方法签名如下所示：

```go
func (c *Client) FPutObject(ctx context.Context, bucketName, objectName, filePath string,
                            opts PutObjectOptions) (info UploadInfo, err error)
```

使用`FPutObject`，客户端需要传入本地文件的相对路径或绝对路径，代码如下：

```go
func FPutFile(c *gin.Context) {
	filePath := c.Query("file-path") // 可为相对路径或绝对路径
	// 从文件名中提取扩展名，并尝试根据扩展名获取Content-Type
	ext := filepath.Ext(filePath)
	contentType := mime.TypeByExtension(ext)
	rnd := rand.New(rand.NewSource(time.Now().UnixNano()))
	objectName := fmt.Sprintf("images/%d%05d%s", time.Now().UnixMilli(), rnd.Intn(100000), ext)
	bucketName := utils.Config.Minio.Bucket
	minioClient, _ := utils.NewMinioClient(bucketName)
	_, _ = minioClient.FPutObject(c.Request.Context(), bucketName, objectName,
		filePath, minio.PutObjectOptions{
			ContentType: contentType,
		})
	wresp.OK(c, objectName)
}
```

这种方式要求待上传的文件必须已存在于本地服务器，无法由用户自行上传。

#### 2. 读取/下载对象

读取指定对象，使用到`GetObject`方法，需要客户端传入对应`MinIO`文件的`Key`，代码如下所示：

```go
func GetFile(c *gin.Context) {
	// 获取请求参数中的对象名
	objectName := c.Query("object-name")
	bucketName := utils.Config.Minio.Bucket
	minioClient, _ := utils.NewMinioClient(bucketName)
	object, _ := minioClient.GetObject(c.Request.Context(),
		bucketName, objectName, minio.GetObjectOptions{})
	defer object.Close()
	// 读取对象为字节数组
	data, _ := io.ReadAll(object)
	// 从对象名中提取扩展名，并尝试根据扩展名获取Content-Type
	ext := filepath.Ext(objectName)
	contentType := mime.TypeByExtension(ext)
	if contentType == "" {
		contentType = "application/octet-stream"
	}
	c.Data(http.StatusOK, contentType, data)
}
```

如果担心一次性`io.ReadAll`加载大文件可能导致内存问题，也可以使用流式返回方式：

```go
c.Header("Content-Type", contentType)
// 直接将对象流拷贝到响应体中
_, _ = io.Copy(c.Writer, object)
```

如果希望在访问上述接口后直接触发文件下载，需要使浏览器触发下载行为。在调用`c.Data`之前，添加以下代码：

```go
c.Header("Content-Type", "application/octet-stream")
c.Header("Content-Disposition", fmt.Sprintf("attachment; filename=%s", path.Base(objectName)))
```

当然，文件下载的触发过程也可以由前端完成，后端只需返回文件名即可：

```go
c.Header("File-Name", path.Base(objectName))
```

如果添加了文件下载逻辑，那么获取文件接口的函数名应该改为`DownloadFile`，更符合业务含义。

#### 3. 删除对象

#### 4. 复制对象

#### 5. 获取对象`Key`列表

#### 6. 获取对象元数据

待办
