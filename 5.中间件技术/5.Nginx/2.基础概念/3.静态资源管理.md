在上一节展示的`Nginx`基础配置文件中，仅定义了一个`server`，监听`localhost:80`端口，并配置了`/`路径的路由。

我们的`Nginx`服务部署在`Linux`上，在主机上需要通过`Linux`的`IP`地址来访问`Nginx`服务，而配置文件中使用的是`localhost`，因此访问时不会准确路由到对应的`server`。然而，即使如此，我们访问根路径时仍能访问到页面。这是因为如果没有匹配的`IP`，`Nginx`会默认路由到第一个定义的`server`。

我们在配置文件中再添加一个`server`，配置`server_name`为`Linux`的`IP`，并修改根路径跳转的`html`，如下所示：

```nginx
server {
    listen       80;
    server_name  123.60.188.152;

    location / {
        root   html;
        index  index2.html;
    }

    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   html;
    }
}
```

这样，在主机上再次通过`Linux`的`IP`访问`Nginx`服务时，页面就会展示出`index2.html`的内容。

接下来我们增加一个`/hello`路径，并为其指定对应的`html`文件：

```nginx
location /hello/ {
    alias html/;
    index hello.html;
}
```

需要注意的是，对于非根路径，应该使用`alias`关键字，而不是`root`关键字。如果我们使用`root`关键字：

```nginx
location /hello/ {
    root  html;
    index hello.html;
}
```

当请求访问`/hello`时，如果在`location`中配置的是`root`，则会将整个`location`匹配到的前缀拼接到`root`指定的路径后面。也就是说，实际查找的路径会变为`html/hello/`，从而在该目录下寻找`hello.html`文件。而如果使用的是`alias`，则会直接将`location`中匹配到的`/hello/`部分替换为`alias`指定的路径`html/`。因此，最终会在`html/`目录下寻找`hello.html`文件。

如果访问`/hello/static`，且该路径被路由到上面的`location`，则使用`root`时会从`html/hello/static`路径下寻找`hello.html`文件，而使用`alias`时则会从`html/static`路径下寻找`hello.html`文件。

需要注意的是，在使用`alias`时，路径的结尾必须加上`/`，否则可能会导致文件路径错误。

在实际项目中，前端使用`Vue`打包后生成的`dist`目录中会包含一个`index.html`文件。我们可以将该目录放到`Linux`服务器的某个目录下，然后通过绝对路径在`alias`指令中指定`dist`目录的路径，并将`index.html`指定为默认页面。这样，在访问项目路径时，`Nginx`会路由到该`index.html`文件，浏览器打开主页面，从而完成前端页面的访问。

`location`块中还可以使用`try_files`关键字。`try_files`的作用是：按顺序检查文件是否存在，如果文件不存在，则执行业务逻辑的兜底处理。例如，当访问`http://localhost/about`并被路由到`location /`时，配置如下所示：

```nginx
location / {
    root html;
    index index.html index.htm;
    try_files $uri $uri/ /index.html;
}
```

该例子中，`try_files`指令会首先在`html`目录下尝试访问`$uri`（即`/about`），如果未找到对应文件，则继续尝试访问`$uri/`（即`/about/`）目录下的`index.html`或`index.htm`文件。如果依然不存在可用文件，最终会返回`/index.html`作为兜底文件。

`location`块中的`proxy_pass`关键字用于将特定路径反向代理到后端服务。配置如下所示：

```nginx
location /api/ {
    proxy_pass http://123.60.188.153:8080;
}
```

一旦请求路径以`/api/`开头，就不直接访问静态文件，而是转发到后端`http://123.60.188.153:8080`。

例如浏览器请求为：

```http
http://123.60.188.152/api/user/info
```

路由到指定路径后，`Nginx`不会去找静态文件，而是自动转发成：

```http
http://123.60.188.153:8080/api/user/info
```

让后端服务去处理该请求，并把响应回传给前端。这样可以让前端和后端请求看起来同源，避免浏览器的跨域问题，且避免前端把后端真实`IP`与端口暴露给用户。

需要注意，当`proxy_pass`的目标`URL`末尾带有斜杠时，例如`http://123.60.188.153:8080/`，`Nginx`会将与`location`匹配的路径部分从原始请求中移除，然后将剩余路径拼接到目标`URL`后再进行转发。也就是说，转发后的请求将变为：

```http
http://123.60.188.153:8080/user/info
```

不仅是浏览器请求，前端向`Nginx`服务器发送的带有`/api/`路径的请求也会匹配到该路由，并转发到指定的后端域名，由后端服务处理。因此，在实际部署中，前端和后端可以部署在不同的服务器上，前端只需调用`Nginx`服务即可完成对后端服务的调用。

在`proxy_pass`指令下，可以使用`proxy_set_header`指令来指定请求转发到后端服务器时，`Nginx`应携带的`HTTP`请求头。通常我们会设置以下三个常见的请求头：

```nginx
location /api/ {
    proxy_pass http://123.60.188.153:8080/;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
}
```

`Host $host`用于将请求头中的`Host`字段设置为客户端请求的主机名，即`server`块中路由匹配的地址。`X-Real-IP $remote_addr`用于在请求转发时携带真实的客户端`IP`地址。`X-Forwarded-For $proxy_add_x_forwarded_for`则用于维护代理链，其格式如下：

```sh
X-Forwarded-For: 客户端IP, 上一级代理IP, Nginx服务器IP
```

这意味着，即使请求经过多层代理，后端服务器仍然能够通过该头信息追踪到最初发起请求的客户端`IP`地址。

假设客户端`192.168.1.10`通过`123.60.188.152`访问`Nginx`，而`Nginx`将请求反向代理转发到后端服务`123.60.188.153:8080`，后端服务器`123.60.188.153`接收到的请求头大致如下：

```sh
Host: 123.60.188.152
X-Real-IP: 192.168.1.10
X-Forwarded-For: 192.168.1.10, 123.60.188.152
```
