在上一节展示的`Nginx`基础配置文件中，仅定义了一个`server`，监听`localhost:80`端口，并配置了`/`路径的路由。

我们的`Nginx`服务部署在`Linux`上，在主机上需要通过`Linux`的`IP`地址来访问`Nginx`服务，而配置文件中使用的是`localhost`，因此访问时不会准确路由到对应的`server`。然而，即使如此，我们访问根路径时仍能访问到页面。这是因为如果没有匹配的`IP`，`Nginx`会默认路由到第一个定义的`server`。

我们在配置文件中再添加一个`server`，配置`server_name`为`Linux`的`IP`，并修改根路径跳转的`html`，如下所示：

```nginx
server {
    listen       80;
    server_name  123.60.188.152;

    location / {
        root   html;
        index  index2.html;
    }

    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   html;
    }
}
```

这样，在主机上再次通过`Linux`的`IP`访问`Nginx`服务时，页面就会展示出`index2.html`的内容。

接下来我们将增加一个`/hello`路径，并为其指定对应的`html`文件：

```nginx
location /hello {
    alias html;
    index hello.html;
}
```

> 需要注意，对于非根路径，不能使用`root`指令，而应使用`alias`指令，除非使用绝对路径。

这样，访问`http://123.60.188.152/hello/`后，页面会展示`hello.html`的内容。

关于`location`块的关键字，这里再介绍`try_files`和`proxy_pass`两个。`try_files`的作用是：按顺序检查文件是否存在，如果文件不存在，则执行业务逻辑的兜底处理。例如，当访问`http://localhost/about`并被路由到`location /`时，配置如下所示：

```nginx
location / {
    root html;
    index index.html index.htm;
    try_files $uri $uri/ /index.html;
}
```

该例子中，`try_files`指令会首先在`html`目录下尝试访问`$uri`（即`/about`），如果未找到对应文件，则继续尝试访问`$uri/`（即`/about/`）目录下的`index.html`或`index.htm`文件。如果依然不存在可用文件，最终会返回`/index.html`作为兜底文件。

`proxy_pass`关键字用于将特定路径反向代理到后端服务。配置如下所示：

```nginx
location /api/ {
    proxy_pass http://backend:8080;
}
```

一旦请求路径以`/api/`开头，就不直接访问静态文件，而是转发到后端`http://backend:8080`。

例如浏览器请求为：

```http
http://123.60.188.152/api/user/info
```

路由到指定路径后，`Nginx`不会去找静态文件，而是自动转发成：

```http
http://backend:8080/api/user/info
```

让后端服务去处理该请求，并把响应回传给前端。这样可以让前端和后端请求看起来同源，避免浏览器`CORS`问题，且避免前端把后端真实`IP`与端口暴露给用户。

需要注意，当`proxy_pass`的目标`URL`末尾带有斜杠时，例如`http://backend:8080/`，`Nginx`会将与`location`匹配的路径部分从原始请求中移除，然后将剩余路径拼接到目标`URL`后再进行转发。也就是说，转发后的请求将变为：

```http
http://backend:8080/user/info
```

