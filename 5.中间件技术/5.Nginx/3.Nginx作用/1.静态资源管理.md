在前文中展示的`Nginx`基础配置文件中，仅定义了一个`server`，监听`localhost:80`端口，并配置了`/`路径的路由。

我们的`Nginx`服务部署在`Linux`上，在主机上需要通过`Linux`的`IP`地址来访问`Nginx`服务，而配置文件中使用的是`localhost`，因此访问时不会准确路由到对应的`server`。然而，即使如此，我们访问根路径时仍能访问到页面。这是因为如果没有匹配的`IP`，`Nginx`会默认路由到第一个定义的`server`。

我们在配置文件中再添加一个`server`，配置`server_name`为`Linux`的`IP`，并修改根路径跳转的`html`，如下所示：

```nginx
server {
    listen       80;
    server_name  123.60.188.152;

    location / {
        root   html;
        index  index2.html;
    }

    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   html;
    }
}
```

这样，在主机上再次通过`Linux`的`IP`访问`Nginx`服务时，页面就会展示出`index2.html`的内容。

接下来我们增加一个`/hello`路径，并为其指定对应的`html`文件：

```nginx
location /hello/ {
    alias html/;
    index hello.html;
}
```

需要注意的是，对于非根路径，应该使用`alias`关键字，而不是`root`关键字。如果我们使用`root`关键字：

```nginx
location /hello/ {
    root  html;
    index hello.html;
}
```

当请求访问`/hello`时，如果在`location`中配置的是`root`，则会将整个`location`匹配到的前缀拼接到`root`指定的路径后面。也就是说，实际查找的路径会变为`html/hello/`，从而在该目录下寻找`hello.html`文件。而如果使用的是`alias`，则会直接将`location`中匹配到的`/hello/`部分替换为`alias`指定的路径`html/`。因此，最终会在`html/`目录下寻找`hello.html`文件。

如果访问`/hello/static`，且该路径被路由到上面的`location`，则使用`root`时会从`html/hello/static`路径下寻找`hello.html`文件，而使用`alias`时则会从`html/static`路径下寻找`hello.html`文件。

需要注意的是，在使用`alias`时，路径的结尾必须加上`/`，否则可能会导致文件路径错误。

在实际项目中，前端使用`Vue`打包后生成的`dist`目录中会包含一个`index.html`文件。我们可以将该目录放到`Linux`服务器的某个目录下，然后通过绝对路径在`alias`指令中指定`dist`目录的路径，并将`index.html`指定为默认页面。这样，在访问项目路径时，`Nginx`会路由到该`index.html`文件，浏览器打开主页面，从而完成前端页面的访问。

`location`块中还可以使用`try_files`关键字。`try_files`的作用是：按顺序检查文件是否存在，如果文件不存在，则执行业务逻辑的兜底处理。例如，当访问`http://localhost/about`并被路由到`location /`时，配置如下所示：

```nginx
location / {
    root html;
    index index.html index.htm;
    try_files $uri $uri/ /index.html;
}
```

该例子中，`try_files`指令会首先在`html`目录下尝试访问`$uri`（即`/about`），如果未找到对应文件，则继续尝试访问`$uri/`（即`/about/`）目录下的`index.html`或`index.htm`文件。如果依然不存在可用文件，最终会返回`/index.html`作为兜底文件。
