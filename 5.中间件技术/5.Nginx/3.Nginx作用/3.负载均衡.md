在上一节我们讲解了`Nginx`完成反向代理的方式。`Nginx`负载均衡的本质，是在反向代理的基础上，将请求从转发到单一后端，扩展为按照一定策略转发到一组后端实例。对客户端而言，后端服务的数量、地址以及分发策略都是不可见的。

负载均衡主要通过`upstream`指令定义后端服务器池，再通过`proxy_pass`将请求转发给该池完成：

```nginx
upstream user_service {
    server 123.60.188.153:8082;
    server 123.60.188.154:8082;
    server 123.60.188.155:8082;
}

server {
    listen 8081;
    server_name 123.60.188.152;

    location /api/ {
        proxy_pass http://user_service;
    }
}
```

上述配置中，`user_service`定义了一个后端服务集群，`location /api/`下的请求不会再直接指向某一个具体`IP`，而是由`Nginx`从后端池中选择一个节点进行转发。当客户端请求地址：

```sh
http://123.60.188.152:8081/api/user/info
```

`Nginx`会将请求转发为以下任意一种：

```sh
http://123.60.188.153:8082/api/user/info
http://123.60.188.154:8082/api/user/info
http://123.60.188.155:8082/api/user/info
```

在未显式指定策略的情况下，`Nginx`默认使用轮询策略。也就是请求会按照后端服务器在`upstream`中定义的顺序依次分发，适用于后端实例性能相近、请求处理时间差异不大的场景。

如果后端服务器性能不一致，可以通过`weight`配置加权轮询，使性能更强的节点承担更多请求，例如：

```nginx
upstream user_service {
    server 123.60.188.153:8082 weight=3;
    server 123.60.188.154:8082 weight=2;
    server 123.60.188.155:8082 weight=1;
}
```

当后端服务需要维持会话状态，而又未使用`Redis`等集中式`Session`存储时，可以使用`ip_hash`策略。该策略会根据客户端`IP`计算哈希值，使同一客户端的请求始终落到同一台后端服务器：

```nginx
upstream user_service {
    ip_hash;
    server 123.60.188.153:8082;
    server 123.60.188.154:8082;
    server 123.60.188.155:8082;
}
```

需要注意，`ip_hash`在后端节点变更时可能导致大量会话重新分配，因此在动态扩缩容场景下需谨慎使用。

对于请求处理耗时差异较大的业务，可以使用最少连接数策略，让请求优先分发给当前连接数最少的后端节点：

```nginx
upstream user_service {
    least_conn;
    server 123.60.188.153:8082;
    server 123.60.188.154:8082;
    server 123.60.188.155:8082;
}
```

该策略在长连接或慢接口场景下通常比轮询更加合理。

在负载均衡场景中，后端节点的健康状态至关重要。`Nginx`的默认失败策略是：在`10s`内失败`1`次后，该节点会被临时标记为不可用，新的请求将不再分发到该节点。直到`10s`后，`Nginx`会重新恢复向该节点转发请求。

我们也可以对指定节点进行自定义的失败策略配置，例如：

```nginx
upstream user_service {
    server 123.60.188.153:8082 max_fails=3 fail_timeout=20s;
    server 123.60.188.154:8082;
    server 123.60.188.155:8082;
}
```

该配置表示`123.60.188.153:8082`这个节点在`20s`内若失败`3`次，将被临时标记为不可用，并在这段时间内不再接收新的请求。待`20s`的`fail_timeout`周期结束后，`Nginx`会重新恢复向该节点转发请求。

也就是说，`Nginx`的默认失败策略就相当于配置了`max_fails=1 fail_timeout=10s`。

在这里，`fail_timeout`在设计上同时承担了两个职责：一方面用于统计失败次数的时间范围，另一方面也作为节点被判定为不可用后的冷却时间。`Nginx`内部仅使用一个统一的时间尺度来处理这两种行为，并未区分独立的“统计窗口”和“恢复窗口”参数。

与单节点反向代理类似，在负载均衡配置中，同样需要为后端服务透传必要的请求头，以便后端正确获取客户端信息：

```nginx
location /api/ {
    proxy_pass http://user_service;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
}
```

这样，无论请求被分发到哪一个后端节点，后端服务都可以从请求头中获取真实的客户端`IP`和完整的代理链信息。
