在单体项目中，通常只有一个数据库，所有的数据操作都由同一个线程执行。这种情况下事务管理相对简单：同一线程内持有一致的数据库连接，只要在开始事务时获取一个`tx`对象，然后将所有需要事务控制的增删改操作统一交由该`tx`对象执行，就能够保证这些操作在一次提交或回滚中保持原子性。这样，如果中途出现错误，直接执行回滚即可撤销之前所有操作，从而保证数据一致性。

然而，在分布式系统或微服务架构中，通常每个服务都会有自己的数据库和独立的数据库连接，这样一来，单体项目中通过统一的`tx`对象实现的本地事务在分布式场景下无法直接应用。例如，前端发起一次调用到服务`A`，服务`A`在处理请求时需要调用服务`B`的接口，二者各自都会对本服务的数据库执行增删改操作。在这个过程中可能存在如下事务问题：

1. 服务`A`调用服务`B`接口成功，但后续代码发生异常。此时服务`B`的事务已成功提交，而服务`A`的事务回滚，导致服务`B`已提交的数据无法被回滚，从而造成系统数据不一致。

2. 服务`A`调用服务`B`接口成功，服务`B`执行成功后，服务`A`提交事务。但若服务`B`后续调用服务`C`执行补充操作失败，服务`B`可以回滚自身事务，但无法回滚服务`A`已提交的事务，从而导致数据不一致。
3. 服务`A`调用服务`B`接口成功，服务`B`已提交事务，但服务`A`在等待响应时因网络抖动未收到结果，误以为调用失败，从而回滚自身事务。最终，服务`A`的数据回滚，而服务`B`的数据保留，导致系统数据不一致。
4. 服务`A`调用服务`B`接口成功，服务`B`已提交事务，但服务`A`在等待响应时因网络抖动未收到结果，误以为调用失败，再次向服务`B`发起请求。如果服务`B`未做幂等性控制，可能造成数据被重复添加或修改。

对于问题`3`和问题`4`，本质上属于同一类网络问题，发生概率较低。当服务`A`在调用服务`B`后未收到返回结果时，不能直接回滚自身事务，而应执行重复发送。服务`B`的接口必须具备幂等性控制，对于可能发生幂等性问题的接口，要求服务`A`在请求中传入全局唯一的`requestId`，例如`UUID`或基于雪花算法生成的`ID`。服务`B`在执行操作时，通过`requestId`进行幂等校验，避免重复处理。如果是由于服务`B`宕机导致的超时，服务`A`在重试多次仍未收到结果时，才应回滚自身事务。

问题`1`和问题`2`都是由于业务逻辑而造成的分布式事务问题。针对这一问题，业界通常有以下几类解决方案：

1. 两阶段提交（`2PC`）
2. 三阶段提交（`3PC`）
3. `TCC`（`Try-Confirm-Cancel`）
4. `Saga`模式（长事务+补偿机制）
5. 本地消息表（最终一致性）

我们引入下方这个分布式事务管理器的第三方库：

```sh
go get github.com/dtm-labs/dtm
```

待办
