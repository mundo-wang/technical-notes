`WebSocket`的一个典型应用场景就是即时通讯。下面以单聊和群聊为例，介绍即时通讯的实现思路。

在使用`WebSocket`进行即时通讯时，用户`A`与用户`B`之间并不会直接建立连接。二者各自与`WebSocket`服务器保持连接。当用户`A`需要向用户`B`发送消息时，消息会先发送至`WebSocket`服务器，再由服务器转发给用户`B`。

在单机模式下，我们可以维护一个`Map`来保存所有在线用户的`WebSocket`连接。由于该`Map`的读取操作远多于写入操作，且存储的数据为简单键值对，因此我们选择使用`sync.Map`。我们将该`Map`定义为全局变量：

```go
var connMap sync.Map
```

该`Map`的`Key`用于存储用户的`ID`，通常为`int`或`string`类型，`Value`则对应用户的`*websocket.Conn`对象。用户客户端连接成功时，将其`userId`与`conn`对象放进该`Map`，断开连接时删除。客户端与服务端之间还需设置心跳机制，若客户端一段时间内无心跳，服务端也需要删除该连接信息。

系统启动时，应让所有用户与`WebSocket`服务建立连接，并将`userId`与对应的连接信息存入`connMap`中。

当用户`A`向用户`B`发起单聊时，用户`A`需要向`WebSocket`服务发送具体的消息内容，并在`Query`中携带用户`B`的`ID`。`WebSocket`服务接收到该请求后，会根据用户`B`的`ID`在`connMap`中查询是否存在连接：

- 若存在连接，则获取其对应的`conn`对象，将消息转发给用户`B`，并将消息存入数据库。

- 若不存在连接，则将消息存入数据库作为离线消息，用户`B`下次上线建立连接后，读取这些离线消息并推送给用户`B`。

由于同一个连接对象在同一时间只能由一个协程执行写操作，因此应为每个连接对象绑定一把锁。可以通过结构体将连接和锁绑定，并将该结构体对象作为`connMap`的`Value`存储。同时，也可以定义一个结构体来封装`connMap`，并给该结构体实现用户建立连接、发送消息等功能的方法，从而避免直接暴露连接对象。示例代码如下：

```go
type connWrapper struct {
	conn *websocket.Conn
	mu   sync.Mutex // 写锁，保证同一连接的并发写安全
}

type ConnManager struct {
	connMap sync.Map // map[int64]*connWrapper
}

// 用户注册连接
func (m *ConnManager) SetConn(userId int64, conn *websocket.Conn) {
	m.connMap.Store(userId, &connWrapper{conn: conn})
}

// 内部调用，获取连接包装对象
func (m *ConnManager) getWrapper(userId int64) (*connWrapper, bool) {
	value, ok := m.connMap.Load(userId)
	if !ok {
		return nil, false // 返回false表示不存在该用户连接
	}
	wrapper := value.(*connWrapper) // 由于Set的时候限制了Value类型，所以这里不会断言失败
	return wrapper, true
}

// 向单个用户发送消息
// 第一个返回值为false，表示不存在该用户连接，交由上层决定如何处理
func (m *ConnManager) SendMessage(userId int64, messageType int, data []byte) (bool, error) {
	wrapper, ok := m.getWrapper(userId)
	if !ok {
		return false, nil
	}
	wrapper.mu.Lock()
	defer wrapper.mu.Unlock()
	err := wrapper.conn.WriteMessage(messageType, data)
	if err != nil {
		wlog.Error("call wrapper.conn.WriteMessage failed").Err(err).Log()
		return true, err
	}
	return true, nil
}

// 关闭并删除连接
func (m *ConnManager) CloseAndDeleteConn(userId int64) {
	wrapper, ok := m.getWrapper(userId)
	if ok {
		wrapper.mu.Lock()
		_ = wrapper.conn.WriteMessage(websocket.CloseMessage,
			websocket.FormatCloseMessage(websocket.CloseNormalClosure, "")) // 对连接对象进行优雅关闭
		_ = wrapper.conn.Close()
		wrapper.mu.Unlock()
		m.connMap.Delete(userId)
	}
}

// 获取当前连接数
func (m *ConnManager) Count() int {
	count := 0
	m.connMap.Range(func(_, _ any) bool {
		count++
		return true
	})
	return count
}
```

在实际开发中，我们可以对上述方法进行扩展，例如封装`WriteJSON`、`NextWriter`等写操作，实现服务端的群发功能等。
