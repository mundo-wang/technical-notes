`WebSocket`的一个典型应用场景就是即时通讯。下面以单聊和群聊为例，介绍即时通讯的实现思路。

在使用`WebSocket`进行即时通讯时，用户`A`与用户`B`之间并不会直接建立连接。二者各自与`WebSocket`服务器保持连接。当用户`A`需要向用户`B`发送消息时，消息会先发送至`WebSocket`服务器，再由服务器转发给用户`B`。

在单机模式下，我们可以维护一个`Map`来保存所有在线用户的`WebSocket`连接。由于该`Map`的读取操作远多于写入操作，且存储的数据为简单键值对，因此我们选择使用`sync.Map`。我们将该`Map`定义为全局变量：

```go
var connMap sync.Map
```

该`Map`的`Key`用于存储用户的`ID`，通常为`int`或`string`类型，`Value`则对应用户的`*websocket.Conn`对象。用户客户端连接成功时，将其`userId`与`conn`对象放进该`Map`，断开连接时删除。客户端与服务端之间还需设置心跳机制，若客户端一段时间内无心跳，服务端也需要删除该连接信息。

系统启动时，应让所有用户与`WebSocket`服务建立连接，并将`userId`与对应的连接信息存入`connMap`中。

当用户`A`向用户`B`发起单聊时，用户`A`需要向`WebSocket`服务发送具体的消息内容，并在`Query`中携带用户`B`的`ID`。`WebSocket`服务接收到该请求后，会根据用户`B`的`ID`在`connMap`中查询是否存在连接：

- 若存在连接，则获取其对应的`conn`对象，将消息转发给用户`B`，并将消息存入数据库。

- 若不存在连接，则将消息存入数据库作为离线消息，用户`B`下次上线建立连接后，读取这些离线消息并推送给用户`B`。

由于`sync.Map`中保存的`Value`类型为`interface{}`，在使用时若要转换为`*websocket.Conn`类型对象，需要通过类型断言实现。为此，我们可以定义一个结构体对`connMap`进行封装，并在其中实现连接的增删改查方法。代码如下：

```go
type ConnManager struct {
	connMap sync.Map
}

func (m *ConnManager) Set(userId int64, conn *websocket.Conn) {
	m.connMap.Store(userId, conn)
}

func (m *ConnManager) Get(userId int64) (*websocket.Conn, bool) {
	value, ok := m.connMap.Load(userId)
	if !ok {
		return nil, false
	}
	conn, _ := value.(*websocket.Conn) // 该处断言理论上不会出错
	return conn, true
}

func (m *ConnManager) CloseAndDelete(userId int64) {
	if conn, ok := m.Get(userId); ok {
		_ = conn.Close()
		m.connMap.Delete(userId)
	}
}
```

在此基础上，可以进一步扩展功能，例如添加消息广播机制，以及获取在线连接数的方法：

```go
func (m *ConnManager) Range(f func(userId int64, conn *websocket.Conn)) {
	m.connMap.Range(func(key, value any) bool {
		userId, ok1 := key.(int64)
		conn, ok2 := value.(*websocket.Conn)
		if ok1 && ok2 {
			f(userId, conn)
		}
		return true
	})
}

func (m *ConnManager) Count() int {
	count := 0
	m.connMap.Range(func(_, _ any) bool {
		count++
		return true
	})
	return count
}
```

