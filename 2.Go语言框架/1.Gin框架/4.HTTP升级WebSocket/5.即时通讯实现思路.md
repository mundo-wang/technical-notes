`WebSocket`的一个典型应用场景就是即时通讯。下面以单聊和群聊为例，介绍即时通讯的实现思路。

在使用`WebSocket`进行即时通讯时，用户`A`与用户`B`之间并不会直接建立连接。二者各自与`WebSocket`服务器保持连接。当用户`A`需要向用户`B`发送消息时，消息会先发送至`WebSocket`服务器，再由服务器转发给用户`B`。

在单机模式下，我们可以维护一个`Map`来保存所有在线用户的`WebSocket`连接。由于该`Map`的读取操作远多于写入操作，且存储的数据为简单键值对，因此我们选择使用`sync.Map`。我们将该`Map`定义为全局变量：

```go
var connMap sync.Map
```

该`Map`的`Key`用于存储用户的`ID`，通常为`int`或`string`类型，`Value`则对应用户的`*websocket.Conn`对象。用户客户端连接成功时，将其`userId`与`conn`对象放进该`Map`，断开连接时删除。客户端与服务端之间还需设置心跳机制，若客户端一段时间内无心跳，服务端也需要删除该连接信息。

系统启动时，应让所有用户与`WebSocket`服务建立连接，并将`userId`与对应的连接信息存入`connMap`中。

当用户`A`向用户`B`发起单聊时，用户`A`需要向`WebSocket`服务发送具体的消息内容，并在`Query`中携带用户`B`的`ID`。`WebSocket`服务接收到该请求后，会根据用户`B`的`ID`在`connMap`中查询是否存在连接：

- 若存在连接，则获取其对应的`conn`对象，将消息转发给用户`B`，并将消息存入数据库消息表。

- 若不存在连接，则将消息存入数据库离线消息表，用户`B`下次上线建立连接后，读取这些离线消息并推送给用户`B`。

由于同一个连接对象在同一时间只能由一个协程执行写操作，因此应为每个连接对象绑定一把锁。可以通过结构体将连接和锁绑定，并将该结构体对象作为`connMap`的`Value`存储。同时，也可以定义一个结构体来封装`connMap`，并给该结构体实现用户建立连接、发送消息等功能的方法，从而避免直接暴露连接对象。示例代码如下：

```go
type connWrapper struct {
	conn *websocket.Conn
	mu   sync.Mutex // 写锁，保证同一连接的并发写安全
}

type ConnManager struct {
	userConnMap sync.Map // map[int64]*connWrapper
}

// 用户注册连接
func (m *ConnManager) SetConn(userId int64, conn *websocket.Conn) {
	m.userConnMap.Store(userId, &connWrapper{conn: conn})
}

// 内部调用，获取连接包装对象
func (m *ConnManager) getWrapper(userId int64) (*connWrapper, bool) {
	value, ok := m.userConnMap.Load(userId)
	if !ok {
		return nil, false // 返回false表示不存在该用户连接
	}
	wrapper := value.(*connWrapper) // 由于Set的时候限制了Value类型，所以这里不会断言失败
	return wrapper, true
}

// 向单个用户发送消息
// 第一个返回值为false时，表示不存在该用户连接，交由上层决定如何处理
func (m *ConnManager) SendMessage(userId int64, messageType int, data []byte) (bool, error) {
	wrapper, ok := m.getWrapper(userId)
	if !ok {
		return false, nil
	}
	wrapper.mu.Lock()
	defer wrapper.mu.Unlock()
	err := wrapper.conn.WriteMessage(messageType, data)
	if err != nil {
		wlog.Error("call wrapper.conn.WriteMessage failed").Err(err).Log()
		return true, err
	}
	return true, nil
}

// 关闭并删除连接
func (m *ConnManager) CloseAndDeleteConn(userId int64) {
	wrapper, ok := m.getWrapper(userId)
	if ok {
		wrapper.mu.Lock()
		_ = wrapper.conn.WriteMessage(websocket.CloseMessage,
			websocket.FormatCloseMessage(websocket.CloseNormalClosure, "")) // 对连接对象进行优雅关闭
		_ = wrapper.conn.Close()
		wrapper.mu.Unlock()
		m.userConnMap.Delete(userId)
	}
}

// 获取当前连接数
func (m *ConnManager) Count() int {
	count := 0
	m.userConnMap.Range(func(_, _ any) bool {
		count++
		return true
	})
	return count
}
```

在实际开发中，我们可以对上述方法进行扩展，例如封装`WriteJSON`、`NextWriter`等写操作，实现服务端的群发功能等。

我们初始化一个全局的`ConnManager`单例，并通过封装`Get`方法对外提供访问能力，从而避免外部直接修改`connManager`对象：

```go
var connManager = &ConnManager{}

func GetConnManager() *ConnManager {
    return connManager
}
```

对于群聊，需要明确一点：群只是一个逻辑概念，本质上是若干用户的逻辑集合。在`WebSocket`层面，群并没有独立的连接。因此，`WebSocket`服务器无法直接向群发送消息，只能将消息逐一发送给群内的在线成员。

例如，用户`A`、`B`、`C`属于同一个群，当用户`A`向群发送消息时，服务器会遍历群成员列表，找到每个成员对应的连接，并依次将消息发送给他们。在这一过程中，若被推送的用户在线，服务器会立即向其发送消息；若用户不在线，则将消息存入离线消息表中。当用户下次上线并建立连接时，服务器会将这些离线消息重新推送给用户。

无论是单聊还是群聊，客户端最终接收到的都是一条消息对象。为了让客户端明确消息的发送者以及消息的来源类型（单聊或群聊），应在消息中包含来源信息与消息类型字段。例如，可以定义一个统一的消息结构体：

```go
type Message struct {
	MessageId   int64  `json:"msgId"`      // 消息唯一ID
	SenderId    int64  `json:"senderId"`   // 发送者ID
	ReceiverId  int64  `json:"receiverId"` // 单聊：接收者ID
	GroupId     int64  `json:"groupId"`    // 群聊：群ID
	MessageType string `json:"msgType"`    // 消息类型：single/group/system...
	Content     string `json:"content"`    // 消息内容
	CreatedAt   string `json:"createdAt"`  // 发送时间
}
```

这样，客户端接收到消息后，就能方便地将消息展示到页面上了。
