`WebSocket`的一个典型应用场景就是即时通讯。下面以单聊和群聊为例，介绍即时通讯的实现思路。

在使用`WebSocket`进行即时通讯时，用户`A`与用户`B`之间并不会直接建立连接。二者各自与`WebSocket`服务器保持连接。当用户`A`需要向用户`B`发送消息时，消息会先发送至`WebSocket`服务器，再由服务器转发给用户`B`。

在代码实现中，我们需要维护一个`Map`来保存所有在线用户的`WebSocket`连接。由于该`Map`的读取操作远多于写入操作，且存储的数据为简单键值对，因此我们选择使用`sync.Map`。我们将该`Map`定义为全局变量：

```go
var clientConnMap sync.Map
```

该`Map`的`Key`用于存储用户的`ID`，通常为`int`或`string`类型，`Value`则对应用户的`*websocket.Conn`对象。用户客户端连接成功时，将其`userId`与`conn`对象放进该`Map`，断开连接时删除。客户端与服务端之间还需设置心跳机制。

系统启动时，所有用户应与`WebSocket`服务建立连接，并将`userId`与对应的连接信息存入`clientConnMap`中。

当用户`A`向用户`B`发起单聊时，用户`A`需要向`WebSocket`服务发送具体的消息内容，并在`Query`中携带用户`B`的`ID`。`WebSocket`服务接收到该请求后，会根据用户`B`的`ID`在`clientConnMap`中查询是否存在连接：

- 若存在连接，则获取其对应的`conn`对象，将消息转发给用户`B`，并将消息存入数据库。

- 若不存在连接，则将消息存入数据库作为离线消息，并可选择通知用户`A`：“对方当前掉线，消息已暂存”。当用户`B`下次上线并成功建立连接后，从数据库中读取这些离线消息并推送给用户`B`。
