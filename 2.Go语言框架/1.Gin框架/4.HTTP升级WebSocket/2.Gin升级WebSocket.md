上一节我们讨论了`WebSocket`的概念、与`HTTP`的区别以及使用场景等内容。在这一节中，我们将重点讲解如何将`HTTP`协议升级为`WebSocket`协议，以及如何使用`WebSocket`连接对象。

首先，我们需要引入操作`WebSocket`的第三方库：

```sh
go get github.com/gorilla/websocket
```

我们定义一个全局变量`upgrader`，它是一个`WebSocket`升级器，负责将普通的`HTTP`连接升级为`WebSocket`连接：

```go
var upgrader = websocket.Upgrader{
	CheckOrigin: func(r *http.Request) bool {
		return true
	},
}
```

这里的`CheckOrigin`方法用于检查请求的来源，确保只有来自可信任的源才能进行升级，这是防范跨站请求伪造（`CSRF`）攻击的一种手段。在这个例子中，我们直接`return true`，表示接受任何来源的`WebSocket`连接。

接着，我们调用`upgrader.Upgrade`方法进行协议升级。该方法的签名如下：

```go
func (u *Upgrader) Upgrade(w http.ResponseWriter, r *http.Request, responseHeader http.Header) (*Conn, error)
```

该方法的参数和返回值解释如下：

1. `http.ResponseWriter`：用于写入`HTTP`响应的接口。在`WebSocket`协议成功升级后，通过该接口向客户端发送响应。例如，在`Gin`框架中，`c.Writer`就是该类型的变量，可以传入该参数。
2. `*http.Request`：包含`HTTP`请求的所有信息，如请求头、请求`URL`、请求方法等。这些信息用于验证协议升级的条件，比如检查请求来源是否合法。在`Gin`框架中，`c.Request`即为该类型的变量，可以传入该参数。
3. `http.Header`：一个映射类型，用于存储`HTTP`响应头信息。可以用来设置协议升级时的响应头部（如协议协商和握手信息）。如果不需要自定义头部，可以传入`nil`，此时将使用默认的响应头。
4. `*Conn`：接口返回值，表示升级后的`WebSocket`连接。通过该连接，可以进行`WebSocket`协议下的消息读取和发送操作。

使用上面的方法，将`HTTP`连接升级为`WebSocket`连接的代码如下：

```go
func UpgradeWs(c *gin.Context) {
	conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
	if err != nil {
		c.Status(http.StatusInternalServerError)
        return
	}
    // TODO:后续使用conn对象完成消息接收与发送
}
```

获得`conn`对象后，我们应该创建一个方法来读取管道中的消息，处理这些消息并发送回复：

```go
func handleWebSocket(conn *websocket.Conn) {
	defer conn.Close()
	for {
		// 从WebSocket中读取消息（客户端发送到WebSocket的消息）
		messageType, p, err := conn.ReadMessage()
		if err != nil {
			// conn.ReadMessage为阻塞调用，若客户端关闭了连接，会返回error：websocket: close 1005 (no status)
			wlog.Warn("call conn.ReadMessage failed").Err(err).Log()
			break // 在这种情况下，需要退出循环，执行defer中内容以关闭WebSocket管道
		}
		receivedMessage := string(p)
		replyMessage := fmt.Sprintf("接收到消息：%s，我做出回复", receivedMessage)
		// 回复响应消息给客户端
		err = conn.WriteMessage(messageType, []byte(replyMessage))
		if err != nil {
			wlog.Error("call conn.WriteMessage failed").Err(err).Field("receivedMessage", receivedMessage).Log()
			break
		}
	}
}
```

这里面使用到了两个方法，其中`conn.ReadMessage`的方法签名如下：

```go
func (c *Conn) ReadMessage() (messageType int, p []byte, err error)
```

返回参数`messageType`用于表示消息的类型，常见有两种取值：

- `websocket.TextMessage`表示文本消息。
- `websocket.BinaryMessage`表示二进制消息。

参数`p`为字节数组形式，表示从客户端读取到的消息内容，服务端应自行转换为原数据格式。

方法`conn.ReadMessage`是一个阻塞调用，当`WebSocket`管道中没有可读取的消息时，它会阻塞程序执行，直到接收到新消息为止。

这里`WriteMessage`方法的方法签名如下：

```go
func (c *Conn) WriteMessage(messageType int, data []byte) error
```

第一个参数`messageType`表示消息的类型，第二个参数`data`是消息内容，类型为字节数组。如果需要发送`JSON`、`XML`等数据，同样使用`TextMessage`类型，将这些数据序列化为字符串字节数组进行发送。如果要发送图片，则应选择`BinaryMessage`类型，将图片文件读取为字节数组后发送，客户端收到后将字节数组写入文件即可还原图片。

除了`WriteMessage`外，我们还可以使用`WriteJSON`来专门发送`JSON`数据，它的方法签名如下：

```go
func (c *Conn) WriteJSON(v interface{}) error
```

实际上，它对`WriteMessage`进行了封装，使用`TextMessage`作为消息类型，并接收任意可被`encoding/json`标准库序列化的数据。

`NextWriter`是一个底层写接口，提供流式写入能力，其方法签名如下：

```go
func (c *Conn) NextWriter(messageType int) (io.WriteCloser, error)
```

`NextWriter`返回一个实现了`io.WriteCloser`接口的`Writer`。你可以多次调用`Write`方法来拼接完整的消息内容，直到调用`Close()`方法后，消息帧才会真正结束。示例代码如下：

```go
w, _ := conn.NextWriter(websocket.TextMessage)
w.Write([]byte("hello "))
w.Write([]byte("world"))
w.Close()
```

上述代码等价于发送一条完整的消息`hello world`。

在`UpgradeWs`接口函数的`TODO`部分，我们使用一个`Goroutine`来启动`handleWebSocket`函数，实现`WebSocket`管道的监听：

```go
go handleWebSocket(conn)
```

`WebSocket`接口同样支持接收`Query`参数与`Header`参数，如下所示：

```go
param := c.DefaultQuery("param", "default_value")
token := c.GetHeader("Authorization")
```

`UpgradeWs`函数是`Gin`框架接口的实现函数，我们通过`GET`请求将其暴露出去：

```go
r := gin.Default()
r.GET("/upgradews", api.UpgradeWs) // 例如UpgradeWs函数在api包下
r.Run(":8081")
```

这样，一个`WebSocket`服务接口就创建好了，客户端调用该接口，即可完成`WebSocket`连接。

