在上一篇文章中，我们已经详细阐述了`Gin`接口的代码结构。接下来，我们将结合“`Gin`进阶返回结构”这一工具，对`Gin`代码结构进行进一步的优化与提升。

我们先在`wresp/codes.go`文件中增加以下两个错误码：

```go
UserNotFound     = NewErrorCode(10006, "未找到对应用户，请检查用户是否存在")
CreateUserFailed = NewErrorCode(10007, "创建用户时出错，请检查创建参数")
```

在这里，错误码应该尽量细化，为每一种错误类型分配一个独立的错误码，同时编写清晰、易于理解的错误信息。

错误码应当应用于`service`层的代码。在此，我们为两个方法添加简洁的错误判断和返回：

```go
type User struct {
	Id   int64  `json:"id"`
	Name string `json:"name"`
}

type UsersService struct {
}

func (u *UsersService) GetUserInfo(id int64) (*User, error) {
	if id == 10 {
		return nil, wresp.UserNotFound
	}
	user := &User{
		Id:   id,
		Name: "zhangsan",
	}
	return user, nil
}

func (u *UsersService) CreateUser(user *User) error {
	return wresp.CreateUserFailed
}
```

接下来对`controller`层的代码进行修改，具体改动如下：

```go
type UsersApi struct {
	service.UsersService
}

func GetUsersApi() *UsersApi {
	return &UsersApi{}
}

func (u *UsersApi) GetUserInfo(c *gin.Context) (interface{}, error) {
	user, err := u.UsersService.GetUserInfo(10)
	if err != nil {
		wlog.Error("call u.UsersService.GetUserInfo failed").Err(err).Log()
		return nil, err
	}
	return user, nil
}

func (u *UsersApi) CreateUser(c *gin.Context) (interface{}, error) {
	user := &service.User{
		Id:   20,
		Name: "lisi",
	}
	err := u.UsersService.CreateUser(user)
	if err != nil {
		wlog.Error("call u.UsersService.CreateUser failed").Err(err).Log()
		return nil, err
	}
	return nil, nil
}
```

可以看到，我们将两个`Gin`接口函数改造为包装后的方法，这样`controller`层可以直接返回`service`层返回的具体错误码对象（透传），并交由“`Gin`进阶返回结构”工具进行处理与返回。

> 在`controller`层对`service`层返回的`error`进行日志打印可能并不合理。由于这类错误通常源于用户的不当操作，如果遭遇恶意攻击，可能会导致系统生成大量`ERROR`级别的日志，从而干扰正常监控。因此，建议避免在此处记录日志。

对于`router`部分的代码逻辑，改动如下所示：

```go
func SetRouter(s *wresp.Server) {
    r := s.Router
	users := r.Group("/api/v1/users")
	{
		users.GET("/get", s.WrapHandler(api.GetUsersApi().GetUserInfo))
		users.POST("/set", s.WrapHandler(api.GetUsersApi().CreateUser))
	}
    s.Router = r
}
```

在每个`router`部分函数的开头，需要从`*wresp.Server`类型的对象`s`中获取`router`对象。完成路由注册后，再将`router`送回`s`。此外，应使用`s.WrapHandler`方法封装`controller`层的方法，以便其返回结果能够直接由工具处理。

接下来是主函数部分的修改，我们把`router`对象的创建逻辑从`router`目录移交到了主函数文件的`NewServer`函数中：

```go
func main() {
	s := NewServer()
	err := s.Router.Run(":8081")
	if err != nil {
		wlog.Error("call r.Run failed").Err(err).Field("port", 8081).Log()
		return
	}
}

func NewServer() *wresp.Server {
	s := &wresp.Server{
		Router: gin.Default(),
	}
	router.SetRouter(s)
	return s
}
```

如果存在多个路由注册函数，可以在`NewServer`函数中统一调用它们进行注册：

```go
func NewServer() *wresp.Server {
	s := &wresp.Server{
		Router: gin.Default(),
	}
	router.SetRouter1(s)
	router.SetRouter2(s)
	router.SetRouter3(s)
	return s
}
```

以上就是对`Gin`的代码框架进行的最终更新版本。
