处理完请求后，需要将响应结果返回给前端。在使用`Gin`框架时，可以通过调用`*gin.Context`类型的对象`c`的方法来写入响应数据，并显式调用`return`。如果无需返回数据或`message`，可以仅写入状态码。示例代码如下：

```go
c.Status(http.StatusOK)
```

在`Gin`框架中，如果不设置状态码，直接`return`，默认会写入状态码`200`。建议手动设置状态码以确保明确的响应。

当需要返回响应参数时，最常用的方式是使用`c.JSON`，代码如下：

```go
c.JSON(http.StatusOK, gin.H{"message": "success", "data": data})
```

其中`gin.H`的定义如下：

```go
type H map[string]interface{}
```

返回的格式是这样的（示例）：

```json
{
    "data": {
        "username": "nihao",
        "address": "lixin"
    },
    "message": "success"
}
```

使用`c.JSON`方法，需要传入状态码以及具体想返回的数据信息（通常为结构体对象）。

如果只想返回普通文本，可以使用以下方式：

```go
c.String(http.StatusOK, "nihaolixin")
```

返回的格式如下所示：

<img src="image/image-20240112111614259.png" alt="image-20240112111614259" style="zoom:60%;" />

除了以上的两种外，还有`c.XML`，传参结构和`c.JSON`一样，只是返回的格式不一样：

```go
c.XML(http.StatusOK, gin.H{"message": "success", "data": data})
```

返回格式如下所示：

```xml
<map>
    <data>
        <Username>nihao</Username>
        <Address>lixin</Address>
    </data>
    <message>success</message>
</map>
```

还有更多方法，这里不再赘述，使用时可查阅相关文档。

在使用`c.JSON`时，会遇到一个问题：返回的`JSON`结构中，`message`字段出现在`data`字段下方，这样的结构显得不够规范。原因在于`gin.H`是一个`map`结构，键的顺序是根据哈希顺序排列的。为了确保返回结果的结构更为规范，并简化返回内容的编写，我们可以预定义一个结构体来表示返回的数据格式：

```go
type Response struct {
	Message string      `json:"message"`
	Data    interface{} `json:"data"`
}
```

可以使用这个`Response`结构体的对象代替`gin.H`的对象：

```go
user := &User{
	Username: username,
	Address:  address,
}
response := &Response{
	Message: "success",
	Data:    user,
}
c.JSON(http.StatusOK, response)
```

这样，返回的`JSON`结构如下所示，看起来更加格式化：

```json
{
	"message": "success",
    "data": {
        "username": "nihao",
        "address": "lixin"
    }
}
```

上述内容仅是对`Gin`接口返回时使用的`API`结构的基础讲解，关于在项目中的进阶应用，请参考我编写的其他相关文章。

我们还可以将数据写入响应头。代码示例如下：

```go
c.Header("Authorization", "f8a20475-0411-42e8-a816-e7d17a0be3c5")
```

上文中的使用`c.JSON`返回响应数据的接口属于一元接口，即客户端发起一次请求，服务端处理后返回一次完整的响应。而流式接口则允许服务端在接收到客户端请求后，持续不断地向客户端推送数据。

与一元接口相比，流式接口更适用于需要实时或分段传输数据的场景，例如实时日志推送或大文件分片下载。其中，`SSE`（`Server-Sent Events`）是一种常见的流式通信方式，服务端可以通过事件流的形式持续向客户端发送数据。相比`WebSocket`，`SSE`更为轻量，尤其适合服务端单向推送的应用场景。

在开始返回流式数据之前，必须设置以下请求头：

```go
c.Header("Content-Type", "text/event-stream")
c.Header("Cache-Control", "no-cache")
c.Header("Connection", "keep-alive")
c.Header("Transfer-Encoding", "chunked")
```

接下来是一个将消息以流式方式分段返回给客户端的示例：

```go
for i := 0; i < 10; i++ {
    fmt.Fprintf(c.Writer, "data: No: %d，Time: %s\n\n", i, time.Now().Format(time.DateTime))
	c.Writer.Flush() // 强制刷新缓冲区，返回一次数据给客户端
	time.Sleep(1 * time.Second)
}
```

根据`SSE`规范，每条事件的数据部分需以`data:`作为前缀，并通过两个换行（即一个空行）来标识消息的结束。因此，一条完整的`SSE`消息格式应如下所示：

```kotlin
data: 第一条返回内容\n
data: 第二条返回内容\n
\n
```

在普通的流式输出场景中（例如`text/plain`格式，或通过控制台使用`curl`时），只需按行输出并调用`Flush()`即可，无需添加`data:`前缀，也不需要特意插入两个`\n`。

使用`Apifox`调用流式接口时，会以时间线的形式逐行显示出如下内容：

<img src="image/image-20250426005415261.png" alt="image-20250426005415261" style="zoom:40%;" />

当所有流式数据返回完毕后，可以在响应体中查看完整的响应内容：

<img src="image/image-20250426005459345.png" alt="image-20250426005459345" style="zoom:40%;" />

如果希望以`JSON`格式作为`SSE`消息体，可以先使用`json.Marshal`将数据编码为`JSON`字符串，然后将其放在`data:`后面：

```go
userBytes, err := json.Marshal(user)
if err != nil {
	fmt.Fprintf(c.Writer, `data: {"error": "failed to encode JSON"}`+"\n\n")
} else {
	fmt.Fprintf(c.Writer, "data: %s\n\n", userBytes)
}
c.Writer.Flush()
```

`SSE`消息体不支持直接传输非字符串类型，必须是文本格式。如果需要流式传输二进制内容（如文件或图片），建议先将其进行`Base64`编码，再作为字符串输出。

`Gin`提供了一个更常用、更便利的方式来返回流式数据，即使用`c.SSEvent`方法。它不仅可以为每条流式数据添加一个额外的`event`属性，还免去了手动拼装`data`，以及对象序列化的操作：

```go
c.SSEvent("user", user)
c.Writer.Flush()
```

时间线展示内容如下所示：

<img src="image/image-20250426010131944.png" alt="image-20250426010131944" style="zoom:40%;" />

响应体中完整的响应内容如下所示：

<img src="image/image-20250426010202833.png" alt="image-20250426010202833" style="zoom:40%;" />

这样，我们可以根据`event`的值，判断这是一条什么样的信息。
