在`Gin`框架中，中间件是一种机制，用于在`HTTP`请求和响应的生命周期中执行操作。它允许你在请求到达处理器之前或响应离开处理器之后插入自定义逻辑。中间件通常用于处理通用功能，如日志记录、身份验证、错误处理等。

`Gin`的中间件本质上是一个普通的接口函数，它必须是`gin.HandlerFunc`类型的函数对象：

```go
type HandlerFunc func(*Context)
```

通过传递`*Context`类型的参数`c`，中间件可以在接口请求的处理前后执行额外的逻辑。

中间件函数的命名应以`Middleware`结尾，并在前缀部分根据功能进行描述，以明确标识其为中间件函数。

我们把所有的中间件函数都写到`middle/middleware.go`文件中。例如要记录每个访问请求的时间戳，代码如下：

```go
func LoggerMiddleware(c *gin.Context) {
	startTime := time.Now() // 处理实际请求之前的逻辑
	c.Next()                // 通过Next将控制权交给下一个处理函数
	endTime := time.Now()   // 处理实际请求之后的逻辑
	latency := endTime.Sub(startTime)
	fmt.Printf("[%s] %s %s %v\n", endTime.Format("2006-01-02 15:04:05"),
		c.Request.Method, c.Request.URL.Path, latency)
}
```

在中间件链中，`c.Next()`用于将控制权传递给下一个中间件或路由处理函数，继续执行后续逻辑。

在设置`Gin`路由时，我们通过`r.Use`来配置该中间件：

```go
r := gin.Default()
r.Use(middle.LoggerMiddleware)
```

这样，在请求对应接口时，`LoggerMiddleware`函数会在接口处理前后执行，从而打印出请求的相关信息。

如果中间件没有在所有接口之前设置，那么在中间件注册代码之前定义的接口将不会应用该中间件：

```go
r := gin.Default()
r.POST("/create", api.CreateUserInfo) // 不会应用LoggerMiddleware中间件
r.Use(middle.LoggerMiddleware)
r.POST("/user/profile", api.UserProfile) // 此处以下注册的接口都会应用该中间件
```

我们可以注册多个路由中间件。在请求进入阶段，它们将按照注册顺序依次执行（`FIFO`）；在请求退出阶段，将按照注册顺序的逆序执行，即后进入的中间件先退出（`LIFO`）。例如中间件代码如下：

```go
func MiddlewareA(c *gin.Context) {
	fmt.Println("MiddlewareA - Before Next")
	c.Next()
	fmt.Println("MiddlewareA - After Next")
}

func MiddlewareB(c *gin.Context) {
	fmt.Println("MiddlewareB - Before Next")
	c.Next()
	fmt.Println("MiddlewareB - After Next")
}
```

注册上面两个中间件的代码如下：
```go
r := gin.Default()
r.Use(middle.MiddlewareA)
r.Use(middle.MiddlewareB)
```

打印内容的顺序（假设接口实现逻辑里面打印了`Handler Executed` ）：

```sh
MiddlewareA - Before Next
MiddlewareB - Before Next
Handler Executed
MiddlewareB - After Next
MiddlewareA - After Next
```

若需中断当前中间件的执行，并将控制权返回给上一个中间件，以继续执行其后置代码，可使用`c.Abort()`系列方法。该方法用于在中间件中检测到条件不满足或发生错误时，终止请求处理流程，跳过后续中间件和接口函数的执行。

这里我们注册三个中间件，并在`MiddlewareB`中增加判断逻辑，使其可以调用`c.Abort()`，代码如下：

```go
func MiddlewareA(c *gin.Context) {
	fmt.Println("MiddlewareA - Before Next")
	c.Next()
	fmt.Println("MiddlewareA - After Next")
}

func MiddlewareB(c *gin.Context) {
	fmt.Println("MiddlewareB - Before Next")
	if c.Query("userName") != "admin" {
		c.Abort() // 终止请求，不执行后续的中间件与接口函数
		return
	}
	c.Next()
	fmt.Println("MiddlewareB - After Next")
}

func MiddlewareC(c *gin.Context) {
	fmt.Println("MiddlewareC - Before Next")
	c.Next()
	fmt.Println("MiddlewareC - After Next")
}
```

如果给`userName`参数传递非`admin`的值，打印内容的顺序如下：

```sh
MiddlewareA - Before Next
MiddlewareB - Before Next
MiddlewareA - After Next
```

根据上面的打印结果，我们发现，`MiddlewareB`的后续代码，接口函数，以及`MiddlewareC`都不会被执行。

如果在调用`c.Abort()`后没有使用`return`，打印结果会是：

```
MiddlewareA - Before Next
MiddlewareB - Before Next
MiddlewareB - After Next
MiddlewareA - After Next
```

原因在于`c.Abort()`只会中断后续的请求处理链路，并不会直接终止当前中间件函数的执行。当代码继续执行到`c.Next()`时，`Gin`会检测到请求已被`Abort()`标记，因此不会再调用后续中间件与接口函数。但由于当前中间件函数本身并未返回，`c.Next()`之后的代码仍然会被正常执行，因此`MiddlewareB - After Next`依然会输出。

如果需要确保当前中间件在`c.Abort()`之后的代码不被执行，在调用`c.Abort()`后应立即使用`return`。

如果使用`c.Abort()`的同时需要返回状态码及相关错误信息，应使用以下方法：

- `c.AbortWithStatus(code int)`：用于中断请求并返回指定的`HTTP`状态码。
- `c.AbortWithStatusJSON(code int, json interface{})`：用于中断请求并返回指定的`HTTP`状态码和`JSON`格式的响应数据。
- `c.AbortWithError(code int, err error)`：用于中断请求并返回指定的`HTTP`状态码和错误信息。

我们也可以为某个路由进行单独的中间件注册，例如：

```go
r.POST("/create", middle.LoggerMiddleware, service.CreateUserInfo)
```

同样，路由组也可以注册中间件，这些中间件只会影响到该路由组的接口。可以使用以下两种方法进行注册：

```go
userGroup := r.Group("/user_info", middle.LoggerMiddleware)

userGroup := r.Group("/user_info")
userGroup.Use(middle.LoggerMiddleware)
```

之前我们创建路由时，通常使用`gin.Default()`方法。这个方法会默认添加`Logger`和`Recovery`中间件，其中`Logger`中间件负责记录请求日志，而`Recovery`中间件用于捕获`panic`，并返回`500`状态码的响应。

如果不需要这两个默认中间件，可以改用`gin.New()`方法创建一个空的路由实例，然后按需添加自定义的中间件。

在中间件之间，或在中间件与后续处理器之间传递参数，可以使用`c.Set(key, value)`方法将数据存入上下文，并在适当的位置通过`c.Get(key)`或者`c.GetString(key)`、`c.GetInt(key)`等方法进行读取，从而实现数据共享与传递。

如果我们需要外部输入参数，并希望根据参数值灵活调整中间件的行为，通常可以通过闭包来实现，如下所示：

```go
func DingLoginMiddleware(required bool) gin.HandlerFunc {
	return func(c *gin.Context) {
        if required {
            // 必须校验钉钉登录，对传入token进行验证
        } else {
            // 不必进行钉钉登录
        }
		c.Next()
	}
}
```

通过在外层函数中接收参数，并在返回的匿名函数中对该参数进行捕获，可以构造出一个携带上下文状态的`gin.HandlerFunc`。随后，将该`HandlerFunc`作为中间件注册到`Gin`路由中使用，代码如下：

```go
r := gin.Default()
r.GET("/need-ding-login", DingLoginMiddleware(true), DingRequiredHandler) // 必须校验钉钉登录
r.GET("/no-ding-login", DingLoginMiddleware(false), DingOptionalHandler)  // 无需钉钉登录
```

