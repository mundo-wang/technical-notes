`Vue 3`是一个用于构建用户界面的渐进式`JavaScript`框架，它的设计灵活，可以逐步集成到项目中，也可以用于构建大型单页应用（`SPA`）。相比于`Vue 2`，`Vue 3`在性能、代码结构和功能特性上都有显著提升。

在`Vue 3`中，有以下的编码规范：

- 编码语言可以采用`JavaScript`或者`TypeScript`，但是官方推荐使用`TypeScript`。
- 代码风格可以选用组合式`API`或者选项式`API`，但是官方推荐编写组合式`API`，这也是`Vue 3`所引入的部分。
- 同时`Vue 3`还给我们提供了很多简写形式，最重要的一个就是`setup`语法糖。

> `Vue 3`兼容大部分`Vue 2`的语法，也引入了许多新特性。接下来将统一讲解`Vue 3`的新语法，摒弃旧版语法。后续提及`Vue`时，默认指的是`Vue 3`，不再讨论`Vue 2`的内容。

之前我们只学习过`JavaScript`，那么`TypeScript`又是什么呢？`TypeScript`是`JavaScript`的超集，也就是说，所有合法的`JavaScript`代码在`TypeScript`中同样有效。`TypeScript`在保留`JavaScript`灵活性的基础上，增加了静态类型检查和其他高级功能，提升了代码的可维护性和开发效率。它们之间存在以下关键区别：

1. `TypeScript`是一种静态类型语言，允许开发者在编译时为变量指定类型，且不需要显式声明每个变量的类型，编译器能够根据上下文自动推断类型。相比之下，`JavaScript`是动态类型语言，变量的类型在运行时才会确定。
2. `TypeScript`需要通过编译器（`tsc`）将`.ts`文件编译为标准的`.js`文件，在此过程中会进行类型检查，生成的`.js`文件再由浏览器或`Node.js`执行。而`JavaScript`则可以直接由浏览器或`Node.js`执行，无需编译。
3. `TypeScript`支持定义接口（`interface`）和类型别名（`type`），能够为对象、函数及其他复杂数据结构指定类型，从而实现更严格的类型检查和代码约束。此外，`TypeScript`还提供了原生的枚举（`enum`）类型，用于定义一组命名的常量。相比之下，`JavaScript`并没有内置的接口、类型定义机制或枚举支持，通常需要借助文档或外部库（如`JSDoc`）来描述对象结构。
4. 由于引入了类型系统，`TypeScript`使得编辑器能够提供更智能的代码补全、重构和错误检测等功能。而`JavaScript`因缺乏静态类型信息，编辑器的提示功能相对较弱，错误往往要到运行时才会被发现。

这里不提供二者代码差异的具体示例，相关的差异细节将在后续的代码中体现。

组合式`API`和选项式`API`是两种不同的编写组件的方式，各自有其特点和使用场景。以下是它们的主要差别：

#### 1. 选项式`API`（`Options API`）

组件逻辑通过多个选项对象（如`data`、`methods`、`computed`、`watch`等）来组织，代码中的各类功能模块是根据这些选项分组的。例如，所有的`methods`写在一起，所有的`data`写在一起。适合逻辑简单、功能明确的场景。

```javascript
export default {
  data() {
    return {
      count: 0
    };
  },
  methods: {
    increment() {
      this.count++;
    }
  }
}
```

选项式`API`的设计基于预定义的一组选项，当需求增加或发生变化时，可能需要不断添加新的选项。随着选项的增加，`API`的接口会变得臃肿且难以维护。当选项数量较多时，选项式`API`的调用方式变得不直观，代码的可读性和可理解性变差。

#### 2. 组合式`API`（`Composition API`）

通过`setup`函数组织组件逻辑，利用组合函数（`composables`）代替传统的`data`、`methods`等选项。这样可以将相关逻辑片段封装到组合函数和`Hooks`中，适用于复杂逻辑或跨组件复用的场景，提升了代码的灵活性和可维护性。

```javascript
import { ref } from 'vue';

function useCounter() {
  const count = ref(0);
  const increment = () => {
    count.value++;
  };
  return { count, increment };
}

export default {
  setup() {
    const { count, increment } = useCounter();
    return { count, increment };
  }
}
```

上面代码中，`useCounter`就是一个组合函数。我们可以看出组合函数把同一选项的`data`、`methods`等相关功能模块化组合，具有高度的灵活性和可扩展性，允许用户自由组合模块来实现复杂的功能，提升了代码的可读性和可维护性。

在比较选项式`API`与组合式`API`时，可以用一个形象的比喻来说明：假设有`10`个人，选项式`API`就像是将这`10`个人的头部、躯干、胳膊和腿部分别拆解并分类存放。相反，组合式`API`则保持了这`10`个人的完整形态。

当我们需要对某个特定的人（例如`A`）进行修改，比如改变其头部和腿部。在选项式`API`下，我们首先需要在头部集合中找到`A`的头部，进行修改后，再在腿部集合中找到`A`的腿部进行修改。这一过程比较繁琐，需要多次查找和操作。而在组合式`API`中，我们只需找到`A`这个完整的对象，即可直接对其头部和腿部进行修改。这样不仅简化了操作流程，还提高了代码的可读性和维护性。

在后续的`Vue`代码编写中，我们都将采用组合式`API`的方式进行开发。
