这是在`zap`日志库基础上，写的一个关于日志输出的小工具。首先我们下载`zap`包：

```sh
go get go.uber.org/zap
```

新建目录`wlog`，里面新建文件`config.go`、`entry.go`、`level.go`，其中`config.go`内容如下：

```go
package wlog

import (
	"log"
	"os"
	"time"

	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

var (
	logger      *zap.Logger
	shanghaiLoc *time.Location
)

func init() {
	var err error
	shanghaiLoc, err = time.LoadLocation("Asia/Shanghai") // 使用CST时间
	if err != nil {
		shanghaiLoc = time.UTC // 如果加载时区出错，则使用UTC时间
	}
	zapConfig := loadZapConfig()
	logger, err = zapConfig.Build()
	if err != nil {
		log.Fatalf("failed to initialize logger, err: %v", err)
	}
}

func isDevEnv() bool {
	switch os.Getenv("ENV") {
	case "dev", "development", "local":
		return true
	default:
		return false
	}
}

func loadZapConfig() zap.Config {
	zapConfig := zap.Config{}
	// 仅当明确是开发环境时，才使用Development配置，其余环境（测试、预发、生产等）统一使用结构化日志
	if isDevEnv() {
		zapConfig = zap.NewDevelopmentConfig()
		zapConfig.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
		zapConfig.OutputPaths = []string{"stdout"}
	} else {
		zapConfig = zap.NewProductionConfig()
		zapConfig.EncoderConfig.TimeKey = "time"
		zapConfig.EncoderConfig.MessageKey = "message"
		zapConfig.EncoderConfig.CallerKey = "line"
		zapConfig.EncoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder
	}
	zapConfig.EncoderConfig.EncodeTime = customTimeEncoder
	zapConfig.EncoderConfig.EncodeCaller = zapcore.ShortCallerEncoder
	zapConfig.DisableStacktrace = true
	return zapConfig
}

func customTimeEncoder(t time.Time, enc zapcore.PrimitiveArrayEncoder) {
	t = t.In(shanghaiLoc)
	enc.AppendString(t.Format(time.DateTime))
}
```

在本地运行项目时，时间显示正常，但在服务器上时间显示比本地早`8`小时，这是因为日志库`zap`默认使用`UTC`来处理时间。为解决这一问题，我们先在`Linux`服务器上使用`date`或者`timedatectl`命令，查看当前所用时区：

<img src="image/image-20240428151343890.png" alt="image-20240428151343890" style="zoom:50%;" />

如果不是`Asia/Shanghai`或者`CST`，我们在`Linux`终端，使用下面命令更改时区：

```sh
sudo timedatectl set-timezone Asia/Shanghai
```

接着我们编写`customTimeEncoder`函数，强制`zap`库使用`Asia/Shanghai`来处理时间，并将时间格式化为指定格式。在配置`zap`日志系统时，将自定义的时间编码器应用到`zap.Config`的`EncoderConfig.EncodeTime`中，以确保日志输出的时间格式正确。

在代码中，我们设置在开发环境时，使用`Development`配置，这需要我们在本地`IDE`中进行相应配置。首先我们打开`Edit`：

<img src="image/image-20251226113546453.png" alt="image-20251226113546453" style="zoom:40%;" />

在弹出的页面中，选择对应的项目，在`Environment`中输入`ENV=development`这个环境变量：

<img src="image/image-20251226113722338.png" alt="image-20251226113722338" style="zoom:40%;" />

若有多个环境变量，中间使用`;`间隔，也可以点击右边对应的图标，在下面的页面进行添加：

<img src="image/image-20251226113908979.png" alt="image-20251226113908979" style="zoom:40%;" />

在使用`Development`配置时，`Debug`级别日志会被正常输出；而在使用`Production`配置时，`Debug`级别日志默认不会输出。

我们在`Development`环境设置了`OutputPaths`属性，它的默认值为标准错误`stderr`：

<img src="image/image-20260122144347566.png" alt="image-20260122144347566" style="zoom:40%;" />

我们设置为标准输出`stdout`。如果不做此设置，日志信息在`IDE`的控制台上都按标准错误打印，展示的颜色为红色。

更改标准输出前，日志是这样的：

<img src="image/image-20251226133959224.png" alt="image-20251226133959224" style="zoom:50%;" />

更改标准输出后，打印任何级别的日志，日志的颜色都是正常的白色了：

<img src="image/image-20251226134054206.png" alt="image-20251226134054206" style="zoom:50%;" />

无论是`Go`标准库中的`log`、`slog`，还是第三方库如`zap`，日志都会输出到`stderr`，例如`Production`环境的默认设置：

<img src="image/image-20260122144530479.png" alt="image-20260122144530479" style="zoom:40%;" />

这是因为在`Unix/Linux`系统的约定中，`stdout`用于承载程序的正常输出结果，而`stderr`则用于输出错误信息和诊断信息。

日志本质上属于程序的诊断数据，主要用于调试、监控以及问题排查，而不应被视为业务层面的正常输出。将日志输出到`stderr`符合系统设计规范和长期实践经验，其核心目的在于将正常输出与诊断信息进行有效分离，从而更便于重定向处理、日志收集以及监控分析。

需要纠正的一点是，在`zap`中，需要明确区分两件事：

1. 日志级别：`Debug`、`Info`、`Warn`、`Error`、`Fatal`、`Panic`。
2. 输出通道：`OutputPaths`、`ErrorOutputPaths`。

`OutputPaths`和`ErrorOutputPaths`分别用于控制日志的正常输出和内部错误输出去向。任意级别的业务日志都会按照`OutputPaths`指定的输出位置进行写入，而`ErrorOutputPaths`仅用于输出`zap`在运行过程中产生的内部错误信息。

如果我们希望在`Production`环境中，由代码直接指定日志的具体输出位置，而不是在运行编译后的可执行文件时通过重定向`stderr`来实现，也可以显式为`OutputPaths`与`ErrorOutputPaths`赋值，如下所示：

```go
config.OutputPaths = []string{"/var/log/app/app.log"}
config.ErrorOutputPaths = []string{"/var/log/app/app.log"}
```

通常，这里的日志文件路径应当通过从配置文件中读取来实现。这里的文件模式默认是覆盖而不是追加。也就是说，每次`logger`初始化时，如果指定的文件存在，它会直接覆盖原有内容，而不会自动追加。

`entry.go`的代码如下所示：

```go
package wlog

import (
	"path"
	"runtime"

	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

type LoggerEntry interface {
	// 注意：打印日志语句必须在调用链的末尾调用.Log()方法，否则日志无法正常输出
	Field(key string, value interface{}) LoggerEntry
	Err(err error) LoggerEntry
	Skip(skip int) LoggerEntry
	Log()
}

type loggerEntry struct {
	level   zapcore.Level
	logger  *zap.Logger
	message string
	skip    int
}

func newLoggerEntry(level zapcore.Level, message string) LoggerEntry {
	return &loggerEntry{
		level:   level,
		logger:  logger,
		message: message,
		skip:    1, // 默认跳过1层调用者
	}
}

// 获取调用日志的函数或方法全名的最后一部分，一般来说是最后一个斜杠后的部分
// 对于函数，其全名为module/paths/pkg.FuncName(其中 paths 是从模块根目录到包的相对路径)，处理后返回的是pkg.FuncName
// 对于方法，其全名同理于函数，处理后返回的是pkg.(*Type).MethodName或者pkg.Type.MethodName
func callerName(skip int) string {
	pc, _, _, ok := runtime.Caller(skip + 1) // 这里需要+1，是因为要先跳转到调用callerName的Log方法
	if ok {
		fullName := runtime.FuncForPC(pc).Name()
		baseName := path.Base(fullName)
		return baseName
	} else {
		return "unknown"
	}
}

func (l *loggerEntry) Field(key string, value interface{}) LoggerEntry {
	l.logger = l.logger.With(zap.Any(key, value))
	return l
}

func (l *loggerEntry) Err(err error) LoggerEntry {
	l.logger = l.logger.With(zap.Error(err))
	return l
}

// 表示跳过调用栈中的若干层，用于控制日志中显示的调用位置。
// 例如：函数A调用函数B，函数B调用函数C，函数C中调用Error方法。
// 默认情况下跳过1层，日志将显示函数C中调用Error的代码位置；
// 若设置为跳过2层，则显示函数B中调用函数C的位置；
// 若设置为跳过3层，则显示函数A中调用函数B的位置。
func (l *loggerEntry) Skip(skip int) LoggerEntry {
	l.skip = skip
	return l
}

func (l *loggerEntry) Log() {
	l.logger.With(zap.String("caller", callerName(l.skip))).
		WithOptions(zap.AddCallerSkip(l.skip)).Check(l.level, l.message).Write()
}
```

我们编写了一个名为`CallerName`的函数，用于获取调用日志的函数或方法的名称。对于函数，其返回格式为`pkgName.FuncName`，对于方法，其返回格式为`pkgName.(*Type).MethodName`或`pkgName.Type.MethodName`。

首先，通过`fullName`获取完整的函数或方法名称，`fullName`包括`GoModules`名和路径名。然后，使用`path.Base`提取名称中的最后一个斜杠后的内容。如果需要获取完整的模块路径信息，可以直接返回`fullName`。

`level.go`文件的代码如下所示：

```go
package wlog

import (
	"fmt"
	"go.uber.org/zap/zapcore"
)

func Debug(message string) LoggerEntry {
	return newLoggerEntry(zapcore.DebugLevel, message)
}

func Info(message string) LoggerEntry {
	return newLoggerEntry(zapcore.InfoLevel, message)
}

func Warn(message string) LoggerEntry {
	return newLoggerEntry(zapcore.WarnLevel, message)
}

func Error(message string) LoggerEntry {
	return newLoggerEntry(zapcore.ErrorLevel, message)
}

func Fatal(message string) LoggerEntry {
	return newLoggerEntry(zapcore.FatalLevel, message)
}

func Panic(message string) LoggerEntry {
	return newLoggerEntry(zapcore.PanicLevel, message)
}

func Debugf(format string, args ...interface{}) LoggerEntry {
	message := fmt.Sprintf(format, args...)
	return newLoggerEntry(zapcore.DebugLevel, message)
}

func Infof(format string, args ...interface{}) LoggerEntry {
	message := fmt.Sprintf(format, args...)
	return newLoggerEntry(zapcore.InfoLevel, message)
}

func Warnf(format string, args ...interface{}) LoggerEntry {
	message := fmt.Sprintf(format, args...)
	return newLoggerEntry(zapcore.WarnLevel, message)
}

func Errorf(format string, args ...interface{}) LoggerEntry {
	message := fmt.Sprintf(format, args...)
	return newLoggerEntry(zapcore.ErrorLevel, message)
}

func Fatalf(format string, args ...interface{}) LoggerEntry {
	message := fmt.Sprintf(format, args...)
	return newLoggerEntry(zapcore.FatalLevel, message)
}

func Panicf(format string, args ...interface{}) LoggerEntry {
	message := fmt.Sprintf(format, args...)
	return newLoggerEntry(zapcore.PanicLevel, message)
}
```

使用日志时，在需要的模块中导入`wlog`包，代码中通过链式调用来实现日志记录。代码示例如下：

```go
wlog.Warnf("Warning number is: %s", "001").Field("name", "zhangsan").Field("age", 30).Log()
```

打印在控制台的结果如下所示：

```sh
2024-04-22 15:47:03	WARN	prac/main.go:17	Warning number is: 001	{"name": "zhangsan", "age": 30, "caller": "common.Hello"}
```

在`GoLand`点一下`prac/main.go:17`的部分，可以直接跳转到代码中打印这条日志的地方，也可以复制这个代码位置信息全文查找。

如果是测试或生产环境，打印的日志是这个样子的，这是一份标准的`JSON`格式数据：

```json
{"level":"WARN","time":"2024-04-22 15:46:22","line":"prac/main.go:17","message":"Warning number is: 001","name":"zhangsan","age":30,"caller":"common.Hello"}
```

如果需要在日志中打印`error`，代码示例如下：

```go
err := errors.New("some errors")
wlog.Error("call xxx failed").Err(err).Field("name", "lisi").Log()
```

打印出的生产环境`JSON`格式日志如下所示：

```json
{"level":"ERROR","time":"2024-12-16 09:43:08","line":"test06/main.go:46","message":"call xxx failed","error":"some errors","name":"lisi","caller":"main.CallSome"}
```

