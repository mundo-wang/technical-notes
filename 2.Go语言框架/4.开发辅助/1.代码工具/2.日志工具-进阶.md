在上一节的日志工具中，我们会发现一个问题，那就是它的调用流程是如下所示的：

```go
wlog.Error("call xxx failed").Err(err).Field("xxx", "xxx").Log()
```

该日志调用最终必须以一个`Log()`方法作为收尾。如果未调用该方法，既不会产生任何编译错误，也不会在运行期报错，但日志将不会被打印。而这个`Log()`方法本身又极易被开发人员忽略，一旦遗漏，就会导致日志缺失，在后续排查问题时会引发困惑。

所以我们设计更改了日志调用链的结构，如下所示：

```go
wlog.Msg("call xxx failed").Err(err).Field("xxx", "xxx").Error()
```

在这里，我们将日志级别方法放在调用链的最后，用以替代原本的`Log()`方法。这样在视觉和使用习惯上可以更直观地引导开发人员完整编写调用链，从而降低被忽略的风险，避免因遗漏而导致日志未打印的问题。

我们更新了`entry.go`文件的代码内容，并删除了`level.go`文件。更新后的`entry.go`文件的代码如下所示：

```go
package wlog

import (
	"context"
	"fmt"
	"path"
	"runtime"
	"time"

	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

const defaultCallerSkip = 2

type traceIdKeyType struct{}

var traceIdKey = traceIdKeyType{}

func WithTraceId(ctx context.Context, traceID string) context.Context {
	return context.WithValue(ctx, traceIdKey, traceID)
}

// 如果没有使用WithTraceId设置trackId，这里会返回空字符串
func GetTraceId(ctx context.Context) string {
	v, _ := ctx.Value(traceIdKey).(string)
	return v
}

type LoggerEntry interface {
	Ctx(ctx context.Context) LoggerEntry
	Field(key string, value interface{}) LoggerEntry
	Err(err error) LoggerEntry
	Skip(skip int) LoggerEntry

	Debug()
	Info()
	Warn()
	Error()
	Fatal()
	Panic()
}

type loggerEntry struct {
	logger     *zap.Logger
	message    string
	callerSkip int
}

func Msg(message string) LoggerEntry {
	return &loggerEntry{
		logger:  logger,
		message: message,
		// 默认跳过2层调用者，write占1层，日志等级方法（如Error()）占1层
		callerSkip: defaultCallerSkip,
	}
}

func Msgf(format string, args ...interface{}) LoggerEntry {
	return Msg(fmt.Sprintf(format, args...))
}

func (l *loggerEntry) Ctx(ctx context.Context) LoggerEntry {
	if ctx != nil {
		traceId, ok := ctx.Value(traceIdKey).(string)
		if ok && traceId != "" {
			l.logger = l.logger.With(zap.String("trace_id", traceId))
		}
	}
	return l
}

func (l *loggerEntry) Field(key string, value interface{}) LoggerEntry {
	switch v := value.(type) {
	case string:
		l.logger = l.logger.With(zap.String(key, v))
	case bool:
		l.logger = l.logger.With(zap.Bool(key, v))
	case int:
		l.logger = l.logger.With(zap.Int(key, v))
	case int8:
		l.logger = l.logger.With(zap.Int8(key, v))
	case int16:
		l.logger = l.logger.With(zap.Int16(key, v))
	case int32:
		l.logger = l.logger.With(zap.Int32(key, v))
	case int64:
		l.logger = l.logger.With(zap.Int64(key, v))
	case uint:
		l.logger = l.logger.With(zap.Uint(key, v))
	case uint8:
		l.logger = l.logger.With(zap.Uint8(key, v))
	case uint16:
		l.logger = l.logger.With(zap.Uint16(key, v))
	case uint32:
		l.logger = l.logger.With(zap.Uint32(key, v))
	case uint64:
		l.logger = l.logger.With(zap.Uint64(key, v))
	case uintptr:
		l.logger = l.logger.With(zap.Uintptr(key, v))
	case float32:
		l.logger = l.logger.With(zap.Float32(key, v))
	case float64:
		l.logger = l.logger.With(zap.Float64(key, v))
	case complex64:
		l.logger = l.logger.With(zap.Complex64(key, v))
	case complex128:
		l.logger = l.logger.With(zap.Complex128(key, v))
	case time.Time:
		l.logger = l.logger.With(zap.Time(key, v))
	case time.Duration:
		l.logger = l.logger.With(zap.Duration(key, v))
	case error:
		l.logger = l.logger.With(zap.NamedError(key, v))
	case []string:
		l.logger = l.logger.With(zap.Strings(key, v))
	case []bool:
		l.logger = l.logger.With(zap.Bools(key, v))
	case []int:
		l.logger = l.logger.With(zap.Ints(key, v))
	case []int8:
		l.logger = l.logger.With(zap.Int8s(key, v))
	case []int16:
		l.logger = l.logger.With(zap.Int16s(key, v))
	case []int32:
		l.logger = l.logger.With(zap.Int32s(key, v))
	case []int64:
		l.logger = l.logger.With(zap.Int64s(key, v))
	case []uint:
		l.logger = l.logger.With(zap.Uints(key, v))
	case []byte:
		l.logger = l.logger.With(zap.Binary(key, v))
	case []uint16:
		l.logger = l.logger.With(zap.Uint16s(key, v))
	case []uint32:
		l.logger = l.logger.With(zap.Uint32s(key, v))
	case []uint64:
		l.logger = l.logger.With(zap.Uint64s(key, v))
	case []float32:
		l.logger = l.logger.With(zap.Float32s(key, v))
	case []float64:
		l.logger = l.logger.With(zap.Float64s(key, v))
	case []time.Time:
		l.logger = l.logger.With(zap.Times(key, v))
	case []time.Duration:
		l.logger = l.logger.With(zap.Durations(key, v))
	case []error:
		l.logger = l.logger.With(zap.Errors(key, v))
	case zapcore.ObjectMarshaler:
		l.logger = l.logger.With(zap.Object(key, v))
	case zapcore.ArrayMarshaler:
		l.logger = l.logger.With(zap.Array(key, v))
	case fmt.Stringer:
		l.logger = l.logger.With(zap.String(key, v.String()))
	default:
		l.logger = l.logger.With(zap.Any(key, value))
	}
	return l
}

func (l *loggerEntry) Err(err error) LoggerEntry {
	l.logger = l.logger.With(zap.Error(err))
	return l
}

// 表示在用户调用位置的基础上，额外向上跳过的调用栈层数，用于控制日志中显示的调用位置
// 实际生效的callerSkip值为：skip + defaultCallerSkip，其中defaultCallerSkip用于屏蔽日志框架自身的调用层级
// 调用链示例：A -> B -> C -> 日志方法
// 不调用Skip，日志显示函数C打印日志的位置
// 设置Skip(1)，日志显示函数B调用函数C的位置
// 设置Skip(2)，日志显示函数A调用函数B的位置
func (l *loggerEntry) Skip(skip int) LoggerEntry {
	l.callerSkip = skip + defaultCallerSkip
	return l
}

// 获取调用日志的函数或方法全名的最后一部分，一般来说是最后一个斜杠后的部分
// 对于函数，其全名为module/paths/pkg.FuncName(其中paths是从模块根目录到包的相对路径)，处理后返回的是pkg.FuncName
// 对于方法，其全名同理于函数，处理后返回的是pkg.(*Type).MethodName或者pkg.Type.MethodName
func callerName(callerSkip int) string {
	pc, _, _, ok := runtime.Caller(callerSkip + 1) // 这里需要+1，是因为要先跳转到调用callerName的write方法
	if ok {
		fullName := runtime.FuncForPC(pc).Name()
		baseName := path.Base(fullName)
		return baseName
	} else {
		return "unknown"
	}
}

func (l *loggerEntry) write(level zapcore.Level) {
	l.logger.
		With(zap.String("caller", callerName(l.callerSkip))).
		WithOptions(zap.AddCallerSkip(l.callerSkip)).
		Check(level, l.message).
		Write()
}

func (l *loggerEntry) Debug() {
	l.write(zapcore.DebugLevel)
}

func (l *loggerEntry) Info() {
	l.write(zapcore.InfoLevel)
}

func (l *loggerEntry) Warn() {
	l.write(zapcore.WarnLevel)
}

func (l *loggerEntry) Error() {
	l.write(zapcore.ErrorLevel)
}

func (l *loggerEntry) Fatal() {
	l.write(zapcore.FatalLevel)
}

func (l *loggerEntry) Panic() {
	l.write(zapcore.PanicLevel)
}
```

除调用链本身发生调整外，日志配置方式及结构化日志的打印内容均保持不变。由于`Skip()`方法的内部实现逻辑有所调整，其参数传递方式也相应发生变化，具体说明可参考上述代码中的注释。

在这里，我们还引入了链路追踪`Id`，用于在接口调用失败时，通过`traceId`快速定位相关日志。

工程上的做法是，后端接口应为每个请求生成一个唯一的`traceId`，无论请求成功还是失败，都将该`traceId`返回给客户端，例如设置响应头`X-Trace-Id: xxx`，或者在响应体中返回：

```json
{
  "code": 50001,
  "message": "内部错误",
  "trace_id": "xxx"
}
```

这样，当调用端发现接口报错时，可以通过`traceId`将问题反馈给接口开发人员，开发人员则可借助该`traceId`快速定位到对应日志，从而高效地分析和解决问题。

在业务接口中，可以通过调用`WithTraceId`将`traceId`写入`ctx`对象，这一步通常应在`Gin`中间件中完成：

```go
func TraceMiddleware(c *gin.Context) {
	ctx := c.Request.Context()
    node, _ := snowflake.NewNode(1)
	traceId := node.Generate() // 生成雪花算法ID
	ctx = wlog.WithTraceId(ctx, traceId)
	c.Request = c.Request.WithContext(ctx) // 把写入了traceId的新ctx写回c.Request中
    c.Next()
}
```

加入`ctx`对象后，日志的调用链就变成下面这样：

```go
wlog.Msg("call xxx failed").Ctx(ctx).Err(err).Field("xxx", "xxx").Error()
```

这样，打印的结构化日志内容如下所示：

```json
{"level":"ERROR","time":"2026-01-09 23:22:14","line":"my-prac/main.go:21","message":"call xxx failed","trace_id":"7415407145912410112","error":"this is an error","xxx":"xxx","caller":"main.main"}
```

后续在`Gin`接口返回时，可以调用`GetTraceId`函数获取之前写入的`traceId`值，从而方便将其返回给调用端。

