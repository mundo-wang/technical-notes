在钉钉企业内部`H5`微应用开发中，我们首先需要明确以下关键概念：

1. `CorpId`：钉钉企业的唯一标识，用于区分不同企业。
2. `AgentId`/`AppID`：企业内部应用的唯一标识。目前钉钉逐步使用`AppID`替代`AgentId`。
3. `ClientID`/`AppKey`：应用的唯一访问标识，相当于应用的`ak`。
4. `ClientSecret`/`AppSecret`：应用的唯一密钥，用于服务端鉴权，相当于应用的`sk`。
5. `authCode`：使用`CorpId`和`ClientID`调用钉钉接口生成临时授权码。该授权码有效期为`5`分钟，且仅能使用一次。这个过程不需要用户主动点击授权，它属于免登流程的一部分，只要用户打开微应用界面，就可以通过`JSAPI`自动获取`authCode`。
6. `accessToken`：通过`ClientID`/`AppKey`和`ClientSecret`/`AppSecret`在钉钉服务端获取的访问令牌。具有一定有效期，需后端缓存，以避免频繁调用接口。
7. 钉钉`userId`：企业内部唯一标识，用于区分同一企业内的不同成员。
8. 钉钉`unionId`：全钉钉全局唯一标识，可跨企业识别同一用户。

我们可以发现，一个`CorpId`与一个`AgentId`可以唯一定位钉钉企业下的一个微应用。由于每个微应用的`authCode`、`AppKey`和`AppSecret`都是独立的，所以每个微应用都需要单独执行完整的登录与鉴权流程。

我们的后端服务需要新建以下两张表：

```sql
CREATE TABLE `ding_talk_app_config` (
  `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `app_type` VARCHAR(64) NOT NULL DEFAULT '' COMMENT '后端自定义的应用标识',
  `corp_id` VARCHAR(128) NOT NULL COMMENT '钉钉企业唯一id',
  `agent_id` VARCHAR(128) NOT NULL COMMENT '企业内部应用唯一id',
  `ak` VARCHAR(128) NOT NULL COMMENT 'ClientID (原AppKey和SuiteKey)',
  `sk` VARCHAR(256) NOT NULL COMMENT 'ClientSecret (原AppSecret和SuiteSecret)',
  `create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='钉钉微应用配置表';

CREATE TABLE `ding_talk_app_user` (
  `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `app_config_id` BIGINT NOT NULL COMMENT '钉钉客户端应用ID，关联ding_talk_app_config.id'
  `user_id` BIGINT NOT NULL COMMENT '用户ID, 关联sys_user.id',
  `user_name` VARCHAR(255) DEFAULT NULL COMMENT '用户名，关联sys_user.name',
  `ding_user_id` VARCHAR(64) NOT NULL COMMENT '钉钉用户的userId',
  `ding_user_name` VARCHAR(255) DEFAULT NULL COMMENT '钉钉用户名字',
  `ding_mobile` VARCHAR(20) DEFAULT NULL COMMENT '钉钉手机号码',
  `ding_union_id` VARCHAR(64) DEFAULT NULL COMMENT '钉钉用户的unionId',
  `create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='钉钉用户微应用登录记录表';
```

表`ding_talk_app_config`用于管理钉钉企业微应用的配置信息，其中每条记录对应一个微应用。表`ding_talk_app_user`用于记录各微应用下已登录的用户信息，实现不同微应用之间的登录信息隔离。字段`app_type`为后端自定义，用于标识每个微应用，前端可通过该字段调用后端接口查询`ding_talk_app_config`表，以获取指定微应用的详细配置信息。

钉钉企业内部微应用免登接入系统平台的开发流程如下：

![image-20250821135941994](image/image-20250821135941994.png)

系统`token`的生成有两种方式：

1. 无状态方式：使用`JWT`生成`token`。
2. 有状态方式：生成随机`token`，并将其作为`key`，用户信息作为`value`存储在`Redis`中。

每个`token`中至少应包含钉钉用户`ID`以及`ding_talk_app_config`表的主键`ID`，它们可以唯一定位`ding_talk_app_user`表的一条数据，从而获取登录用户信息。此外，`token`应设置有效期，例如`48`小时，并将该过期时间一并返回给前端。

我们以有状态`token`为例，说明系统接入钉钉服务并获取到`token`后，再次进行登录时的校验流程：

![image-20250821140807626](image/image-20250821140807626.png)

在后续登录过程中，前端需传递对应微应用返回的`token`。对于`accessToken`的管理，可以将其存储在`Redis`中：使用固定前缀加上`ak`作为`key`，将`accessToken`作为`value`，并设置有效期。这样，在免登录场景下，系统可以根据`ak`拼装`key`尝试获取`accessToken`，若获取成功，则直接使用，若未获取到，则重新生成并存储。

钉钉企业内部微应用免登接入系统平台，其`plantUML`代码如下所示：

```scss
@startuml
actor 前端
participant 钉钉服务
participant 后端
database ding_talk_app_config as Config表
database ding_talk_app_user as 钉钉User表
database sys_user as 系统User表

前端 -> 钉钉服务 : 调用接口，传入corpId、clientID，获取authCode
钉钉服务 --> 前端 : 返回authCode（过期时间非常短，使用一次后无效）
前端 -> 后端 : 提交authCode、corpId、agentId（确定企业下的唯一应用）

后端 -> Config表 : 根据corpId、agentId查询应用信息
Config表 --> 后端 : 返回ak、sk

后端 -> 钉钉服务 : 使用ak、sk获取accessToken（这里省略accessToken的存储）
钉钉服务 --> 后端 : 返回accessToken

后端 -> 钉钉服务 : 使用authCode、accessToken获取用户信息
钉钉服务 --> 后端 : 返回dingUserId等信息

后端 -> 钉钉User表 : 使用dingUserId与ding_talk_app_config主键ID，查询该用户是否登录过该应用
alt 已登录
    钉钉User表 --> 后端 : 返回用户记录
else 未登录
    后端 -> 钉钉服务 : 使用dingUserId、accessToken获取用户详细信息
    钉钉服务 --> 后端 : 返回手机号、用户名等
    后端 -> 系统User表 : 根据手机号查询平台用户
    alt 已匹配到用户
        系统User表 --> 后端 : 返回平台用户记录
        后端 -> 钉钉User表 : 新增钉钉用户记录
    else 未匹配到用户
        系统User表 --> 后端 : 返回无匹配平台用户信息
        后端 --> 前端 : 返回错误信息，提示用户需要先在平台注册登录
    end
end

后端 -> 后端 : 生成系统token
后端 -> 前端 : 返回系统token
@enduml
```

获取到`token`后，再次进行登录时的校验流程，其`plantUML`语法如下所示：

```scss
@startuml
actor 前端
participant 鉴权组件
database Redis as Token缓存
database ding_talk_app_user as 钉钉User表
participant 后端服务

前端 -> 鉴权组件 : 请求该应用下其他接口，携带系统token

alt token为空
    鉴权组件 --> 前端 : 返回错误信息，提示重新登录
else token不为空
    鉴权组件 -> Token缓存 : 根据token查询用户信息
    alt token存在且未过期
        Token缓存 --> 鉴权组件 : 返回钉钉用户ID、ding_talk_app_config表主键ID
        鉴权组件 -> 钉钉User表 : 根据钉钉用户ID、ding_talk_app_config表主键ID，查询该用户是否登录过该应用
        钉钉User表 --> 鉴权组件 : 查询到记录，返回用户信息
        鉴权组件 -> 后端服务 : 校验通过，执行业务逻辑（这里省略获取accessToken步骤）
        后端服务 --> 前端 : 返回业务结果
    else token不存在或已过期
        Token缓存 --> 鉴权组件 : 没有查询到该token
        鉴权组件 --> 前端 : 返回错误信息，提示重新登录
    end
end
@enduml
```

