`go.work`是`Go`语言自`go 1.18`版本引入的一个新特性，用于管理由多个`GoModules`组成的工作区。它的主要作用是方便在本地开发环境中协同开发多个模块，通过使用`go.work`文件，可以将多个模块组合成一个统一的工作区，使得这些模块之间能够直接相互引用，而无需将它们提前发布到远程仓库，从而提升开发效率与调试体验。

举个例子，假设`Module-b`的模块路径是`github.com/mundo-wang/module-b`。如果没有`go.work`文件，想在`Module-a`中使用`Module-b`，通常需要先将`Module-b`的代码推送到远程仓库（例如`GitHub`），然后在`Module-a`中执行`go get github.com/mundo-wang/module-b`命令，引入该模块，才能使用其中提供的方法。

当`Module-b`处于频繁开发和迭代阶段时，每次改动都必须先推送到远程仓库，`Module-a`还需要手动更新依赖，才能获取到最新的修改内容。这种方式会带来额外的操作流程，增加开发成本。而引入`go.work`文件后，只需将`Module-a`和`Module-b`纳入同一个工作区，无需将代码发布到远程仓库，`Module-a`就可以直接引用本地的`Module-b`，实现模块间的本地联调，显著提升开发效率与协作体验。

在介绍`go.work`文件之前，先了解一个概念：工作区（`workspace`）。工作区是一个包含一个或多个`Go`模块的目录结构，每个`Go`模块都有其独立的`go.mod`文件。以下是一个简单的目录结构示例，其中名为`my-workspace`的目录即为工作区目录：

```scss
my-workspace/
├── module-a/
│   └── go.mod
├── module-b/
│   └── go.mod
├── module-c/
│   └── go.mod
└── go.work
```

如果一个项目包含多个彼此独立的`GoModules`模块，那么它们所在的上级目录（即用于聚合多个模块的目录）本身不需要，也不应该被`GoModules`管理。这个目录只是一个逻辑上的工作区，用于组织多个模块，通常不包含实际的业务代码。

因此，不应该在上面的`/my-workspace`这样的聚合目录下创建`go.mod`文件。否则，可能会导致`GoModules`嵌套，引发依赖解析冲突或管理混乱。在这种场景下，每个模块应作为独立的`Module`分别管理，并通常在服务器上各自独立部署。

在上面的目录结构中，`go.work`文件的内容如下：

```go
go 1.21

use (
    ./module-a
    ./module-b
    ./module-c
)
```

`go 1.21`为当前环境`Go`的版本，文件中使用`use`将`module-a`、`module-b`和`module-c`包含在同一个工作区中。

我们一般使用`Go`工具链的命令来自动创建并初始化`go.work`文件，首先进入到工作区目录，执行下方命令：

```sh
go work init ./module-a ./module-b ./module-c
```

如果已经有了`go.work`文件，想添加一个新的模块到工作区，命令如下：

```sh
go work use ./module-d
```

想从`go.work`文件移除一个模块，直接去文件里把该模块手动删除即可，或者使用以下命令：

```sh
go work edit -dropuse ./module-d
```

启用`go.work`文件后，在该工作区目录或其子目录下执行的`go`命令将在整个工作区范围内生效。这意味着命令执行时会同时考虑工作区中的所有模块，而不仅限于当前所在的模块。

一般情况下，`go.work`文件主要用于本地开发调试，不需要提交到`Git`仓库，因此应将其添加到`.gitignore`中加以忽略。

在将`module-a`、`module-b`和`module-c`添加到`go.work`文件后，它们即可相互调用对方的方法。例如下面结构：

```scss
my-workspace/
├── module-a/
│   ├── atool/
│   │   └── tool.go
│   ├── go.mod
│   └── main.go
├── module-b/
│   ├── btool/
│   │   └── tool.go
│   ├── go.mod
│   └── main.go
├── module-c/
│   └── go.mod
└── go.work
```

在`module-a`的`main.go`中，可以直接调用`module-b`中定义的函数，而无需在`go.mod`中显式声明依赖：

```go
package main

import (
	"fmt"
	"github.com/mundo-wang/module-b/btool"
)

func main() {
	result := btool.AddString("Mundo", "Wang")
	fmt.Println(result)
}
```

