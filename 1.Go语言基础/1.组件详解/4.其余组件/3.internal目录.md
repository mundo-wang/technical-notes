在`Go`语言中，结构体、字段以及函数是否对外可见由标识符首字母的大小写决定。在包层面，可以通过`internal`目录来限制包的可访问范围，当某个包位于`internal`目录下时，`Go`编译器会强制规定：该包只能被`internal`目录的父级目录及其子目录中的包所导入，任何其他外部包均无法访问。这种机制可以避免该包被外部调用方误用的风险。

假设项目的目录结构如下所示：

```scss
myproject/
├── pkg/
│   ├── internal/
│   │   ├── foo/
│   │   └── bar/
│   ├── other/
│   │   └── others.go
│   └── package.go
│── cmd/
│   ├── app/
│   │   └── app.go
│   └── command.go
├── main.go
└── go.mod
```

在上面这个目录结构中：

- `pkg/internal`目录下的`foo`和`bar`目录可以被`pkg`目录下的所有目录访问，因此`pkg/other/others.go`和`pkg/package.go`均可以导入`internal`目录，并调用`foo`和`bar`目录中的函数。
- 由于`cmd`目录不位于`pkg`目录下，因此`cmd/app/app.go`和`cmd/command.go`无法导入`internal`目录中的包，也就无法使用`foo`和`bar`目录中的结构体、函数与方法等。
- 由于项目根目录`myproject`下的`main.go`不位于`pkg`目录下，所以该文件无法导入`internal`目录中的包，也就无法使用`foo`和`bar`目录中的结构体、函数与方法等。

如果强行在不能访问`internal`目录的文件中引入`internal`目录下的包，将会导致以下编译错误：

```sh
Use of the internal package is not allowed
```

在上述代码结构中，可以发现，项目的主`main.go`文件无法访问`internal`目录下的包，只能通过`pkg`目录间接使用其提供的能力。实际上，上文仅用于讲解`internal`目录的访问规则，采用了直观的示例。在实际项目中，更合理的做法是将`internal`目录放置在项目根目录下，项目内任意目录中的文件都可以访问`internal`目录中的内容，并直接使用其提供的能力。

这种情况下，`internal`目录封装的就不是项目内部的访问，而是外部项目的访问。例如下面的目录结构：

```scss
wtool/
├── internal/
│   └── biz/
│── cmd/
│   ├── app/
│   │   └── app.go
│   └── command.go
├── tool.go
└── go.mod
```

这种项目一般为工具项目，其根目录的`package`不应该为`main`，项目内的所有其他文件都可以访问`internal/biz`目录，并使用其提供的能力。但如果有其他项目通过`go get`引入该项目，则不允许直接使用`internal`包中的能力。

例如，上述项目的`module`为`github.com/mundo-wang/wtool`，外部项目就不能以这种方式引入并使用它：

```go
import "github.com/mundo-wang/wtool/internal/biz"
```

这会导致编译错误：

```sh
Use of the internal package is not allowed
```

