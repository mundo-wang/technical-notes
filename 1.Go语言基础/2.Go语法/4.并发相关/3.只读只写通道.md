在学习`Go`语言的通道时，我们会接触到只读通道和只写通道的概念，例如，`<-chan int`表示一个只读通道，而`chan<- int`表示一个只写通道。不过，你可能会疑惑，创建一个只读或只写的通道有什么意义？只读通道只能从中读取数据，而无法写入，似乎读取到的只能是空值；同样，只写通道只能写入数据，而无法读取，即使写入数据也无法读取，似乎没有任何意义。

实际上，在`Go`语言中，设置只读或只写通道的主要目的是对通道访问权限进行限制。通过将通道的读取和写入操作分离，确保某些函数或`goroutine`只能执行读取或写入操作，从而增加了代码的安全性。这种限制可以防止误操作，减少竞态条件或死锁等问题的发生。

例如函数`ReadFromChannel`设置只读通道为参数，在函数内部尝试向只读通道中写入，就会有编译错误：

```go
func ReadFromChannel(c <-chan int) {
	// c <- 20  // 尝试写入，会报编译错误
	value := <-c
	fmt.Println(value)  // 打印30
}

func main() {
	c := make(chan int, 3)
	c <- 30
	ReadFromChannel(c)
}
```

或者函数`WriteToChannel`设置只写通道为参数，在函数内部尝试从只写通道中读取，就会有编译错误：

```go
func WriteToChannel(c chan<- int) {
	// value := <-c  // 尝试读取，会报编译错误
	// fmt.Println(value)  
	c <- 20
}

func main() {
	c := make(chan int, 3)
	WriteToChannel(c)
	value := <-c
	fmt.Println(value)  // 打印20
}
```

我们注意到，在函数外部创建的通道是双向通道，可以将该通道传递给参数类型为单向通道的函数或方法。

只读和只写通道的设计目的是限制通道的访问权限，以便在编译期间检测不合法的读取或写入操作，从而提高代码的安全性和健壮性。