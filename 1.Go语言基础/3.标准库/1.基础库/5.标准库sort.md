在`Go`语言中，`sort`库专门用来对切片进行排序，包括基本类型切片与自定义切片。

`sort`包中的`sort.Ints`、`sort.Float64s`、`sort.Strings`方法分别用于对三种基本类型切片执行排序操作：

```go
nums := []int{5, 1, 3, 2, 4}
sort.Ints(nums)
fmt.Println(nums) // [1 2 3 4 5]

values := []float64{3.14, 1.01, 2.72, 1.41}
sort.Float64s(values)
fmt.Println(values) // [1.01 1.41 2.72 3.14]

names := []string{"Bob", "Alice", "Eve", "David"}
sort.Strings(names)
fmt.Println(names) // [Alice Bob David Eve]
```

同样地，`sort`包也提供了判断三种基本类型切片是否已排序的方法：

```go
ok := sort.IntsAreSorted(nums)
ok := sort.Float64sAreSorted(values)
ok := sort.StringsAreSorted(names)
```

使用`sort.Slice`可以按某个字段排序一个结构体切片，代码如下所示：

```go
type User struct {
	Age  int
	Name string
}

func main() {
	users := []User{
		{Age: 30, Name: "Alice"},
		{Age: 20, Name: "Bob"},
	}
	sort.Slice(users, func(i, j int) bool {
		return users[i].Age < users[j].Age // 年龄小的排在前面
	})
	fmt.Println(users) // [{20 Bob} {30 Alice}]
}
```

这里的`Slice`函数的第二个参数是一个比较函数，用于告诉排序算法在比较索引`i`与索引`j`的元素时，哪一个应当排在前面。本示例设定当索引`i`元素的年龄小于索引`j`元素的年龄时返回`true`，表示年龄小的排在前面。

我们也可以设定多字段比较策略，例如先按年龄进行升序排序，若年龄相同，则再按照名字的字母顺序进行排序：

```go
sort.Slice(users, func(i, j int) bool {
	if users[i].Age != users[j].Age {
		return users[i].Age < users[j].Age // 年龄升序
	}
	return users[i].Name < users[j].Name // 若年龄相同则按Name字母顺序
})
```

`sort.Slice`属于不稳定排序。若希望在排序过程中保持相等元素的原始相对顺序，可以改用`sort.SliceStable`实现稳定排序：

```go
sort.SliceStable(users, func(i, j int) bool {
    return users[i].Age < users[j].Age
})
```

若需要复用排序规则，可以自定义结构体切片类型，并通过实现`sort.Interface`接口来完全掌控排序过程：

```go
type User struct {
	Age  int
	Name string
}

type Users []User

func (u Users) Len() int {
	return len(u)
}
func (u Users) Less(i, j int) bool {
	return u[i].Age < u[j].Age
}
func (u Users) Swap(i, j int) {
	u[i], u[j] = u[j], u[i]
}

func main() {
	users := []User{
		{Age: 30, Name: "Alice"},
		{Age: 20, Name: "Bob"},
	}
	sort.Sort(Users(users)) // 类型转换
	fmt.Println(users)
}
```

在这里，`Len`方法用于返回切片的元素数量，`Less`方法与`Slice`函数的第二个参数作用一致，都是用于设定比较规则，`Swap`方法则定义了在排序算法决定交换两个元素时，具体的交换操作应如何执行。

同样地，`sort.Sort`属于不稳定排序，若想要稳定排序，可使用`sort.Stable`替代：

```go
sort.Stable(Users(users))
```

`sort`包内部采用三种算法的混合策略：快速排序作为整体框架，堆排序用于规避快速排序的最坏情况，而插入排序则在处理小规模区间时发挥优势。这种组合方式在性能与可靠性之间取得了良好平衡。

除了排序操作，`sort`还提供了二分查找相关方法，包含三种基础类型切片与结构体类型切片：

```go
idx := sort.SearchInts(nums, 3)
fmt.Println(idx, nums[idx]) // 索引值2，元素值3

idx := sort.SearchFloat64s(values, 2.72)
fmt.Println(idx, values[idx]) // 索引值2，元素值2.72

idx := sort.SearchStrings(names, "David")
fmt.Println(idx, names[idx]) // 索引值2，元素值David
```

对于基础类型的二分查找，返回的`idx`总是“第一个大于等于目标值的位置”，即使切片中不存在目标值。

> 二分查找要求切片必须处于有序状态，这是不可忽视（硬性）的前提条件。

对于结构体类型切片的查找，可以使用`sort.Search`方法。例如有一个按年龄升序排序的`User`类型切片：

```go
users := []User{
    {Age: 18, Name: "Alice"},
    {Age: 20, Name: "Bob"},
    {Age: 25, Name: "Charlie"},
    {Age: 30, Name: "David"},
}
```

我们可以查找第一个年龄大于等于`25`的人：

```go
idx := sort.Search(len(users), func(i int) bool {
    return users[i].Age >= 25
})
fmt.Println(idx, users[idx]) // 索引值2，元素值{25 Charlie}
```

