二维码本质上是一个信息编码的二维矩阵，其存储的数据以字符串形式存在。凡是能够序列化为字符串的数据，都可以嵌入其中。

下面我们引入`Go`语言最常用的第三方库，用于生成二维码：

```sh
go get github.com/skip2/go-qrcode
```

我们以用户扫码后跳转到百度网页为例，代码实现如下：

```go
_ = qrcode.WriteFile("https://baidu.com", qrcode.Medium, 256, "qrcodes/baidu.png")
```

它会将`https://baidu.com`生成二维码图片，并保存到项目根目录下的`qrcodes`目录中，用户扫码后可以直接跳转百度页面。

其中`WriteFile`函数的签名如下所示：

```go
func WriteFile(content string, level RecoveryLevel, size int, filename string) error
```

- 参数`content`表示要嵌入二维码中的字符串。`go-qrcode`库会自动选择合适的二维码版本，以保证该字符串能被编码进去。
- 参数`level`表示容错级别，可选值为`Low`、`Medium`、`High`、`Highest`。二维码的容错级别（`Error Correction Level`）指二维码在部分区域损坏、被遮挡或模糊时仍能被正确识别的能力，默认为`Medium`。容错级别越高，可存储的内容越少。
- 参数`size`表示二维码图片的像素（`px`），例如`256`表示生成的二维码宽度和高度均为`256px`。二维码能存储的内容量与像素大小无关，而是由二维码版本和容错级别决定的。假设二维码需要`32x32`个模块，目标图片大小为`256px`，则每个模块大小为`256/32 = 8px`；如果将`size`改为`512`，每个模块大小则为`16px`，二维码显示会更清晰。
- 参数`filename`表示二维码文件的保存路径，可使用绝对路径或相对路径。

如果想将生成的二维码作为字节流返回给前端，代码实现如下：

```go
qrBytes, _ := qrcode.Encode("https://baidu.com", qrcode.Medium, 256)
```

`Encode`函数的函数签名如下所示：

```go
func Encode(content string, level RecoveryLevel, size int) ([]byte, error)
```

得到`[]byte`类型的二维码字节数组后，即可将其以字节流形式返回给前端，使用`Gin`框架实现如下：

```go
c.Data(http.StatusOK, "image/png", qrBytes)
```

如果想修改二维码的前景色和背景色，可以使用如下代码：

```go
myQrcode, _ := qrcode.New("https://baidu.com", qrcode.Medium)
myQrcode.ForegroundColor = color.RGBA{R: 255, G: 0, B: 0, A: 255}     // 红色
myQrcode.BackgroundColor = color.RGBA{R: 255, G: 255, B: 255, A: 255} // 白色
_ = myQrcode.WriteFile(256, "qrcodes/colored-baidu.png")
```

其中`New`函数的函数签名如下所示：

```go
func New(content string, level RecoveryLevel) (*QRCode, error)
```

该函数返回的`myQrcode`对象可以替代`qrcode`使用，来调用对应的方法，后续可以直接修改其属性，以满足特定需求。

二维码实际上存储的是一段字符串，不同的扫码设备或软件会根据约定的格式进行解析。常见解析方式如下：

- 字符串没有特殊前缀，且没有约定时，扫码设备通常会直接显示为普通文本，用户可以查看或手动复制。
- 字符串以`http://`或`https://`开头时，扫码设备会识别为网址，通过内置浏览器打开或在用户确认后跳转访问。
- 字符串以`weixin://`、`alipay://`等开头时，表示这是平台的应用内协议，可直接唤起对应客户端并执行指定操作。
- 若是自定义字符串格式，通过特定的`APP`或设备扫描后，可识别出对应的字符串，并解析其内容，执行相应操作。
- 在车票、电影票、登机牌等场景中，字符串内容通常为订单号或唯一编码，扫码设备会将其上传至后台系统进行校验。
- 字符串符合标准格式（如`BEGIN:VCARD ... END:VCARD`）时，扫码设备会识别为联系人信息，并提供保存到通讯录的选项。
- 字符串格式为`WIFI:T:WPA;S:mynetwork;P:mypass;;`时，扫码后会被识别为`Wi-Fi`连接信息，并提示用户连接网络。

如果需要在二维码中保存图片信息，不应直接将图片的`Base64`编码字符串写入二维码。正确的做法是先将图片文件保存到服务器本地磁盘或对象存储（如`MinIO`或阿里云`OSS`等），然后将对应的访问`URL`地址写入二维码中。

无论是使用微信、支付宝等`APP`的扫码功能，还是通过扫码枪等设备，二维码的解码过程都是在客户端完成的，而不是在服务端。客户端会根据字符串的格式及后端的约定，选择进行展示、跳转，或将其传递给对应的后端`HTTP`接口进行进一步处理。

下面以支付场景中的两种情况说明扫码的具体流程：

- 用户扫商户收款码：商户收款码通常是固定的，其内容为一个固定的`URL`，其中包含商户账户标识等信息。用户扫码后会进入付款界面，系统根据`URL`中的信息确定收款方，用户输入付款金额后完成支付。

- 商户扫用户付款码：用户付款码是在用户打开支付平台付款码界面时动态生成的二维码，内部保存一个一次性授权码。商户通过扫码设备扫描用户付款码，设备解码后将一次性授权码上传至后端，由后端调用支付接口完成扣款。

如果需要实现前端扫码跳转网页并携带参数的业务流程，后端可以将跳转地址与参数信息拼接后写入二维码，例如`https://example.com/exam/form?exam-id=10`。用户扫码后，浏览器会自动访问该`URL`。前端在该路径中可获取到`exam-id`参数，并展示对应表单供用户填写。用户填写完成并点击确认时，前端在请求接口时可将`exam-id`添加到参数提交。

若`exam-id`属于敏感信息，不适合直接暴露在二维码中，可以通过加密或短链方式保护参数，例如：

- 后端对`exam-id`进行加密，前端扫码后再请求后端解密以获取真实`exam-id`。
- 后端将`exam-id`映射为临时短链标识，前端在接口中传递该标识，后端根据映射获取真实`exam-id`。

相同字符串生成的二维码是完全一致的。如果需要为二维码设置过期时间，可以在`http`链接中携带一个随机生成的`token`，并将该`token`保存到`Redis`中，同时设置过期时间；也可以在链接中携带`expires`字段，记录过期时间点的秒级时间戳。扫码后，后端可根据`token`或`expires`字段进行校验，判断二维码是否过期。若已过期，则需要重新生成新的二维码，前端再次扫码。
