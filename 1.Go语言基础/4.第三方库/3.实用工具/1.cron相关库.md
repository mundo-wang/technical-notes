> 推荐一个好用的`cron`表达式生成网页：https://cron.ciding.cc/。

在学习标准库`time`时，我们接触到了`time.Ticker`类型。它可以通过调用`time.NewTicker()`创建，并传入一个时间间隔，随后即可等待定时器按固定频率触发。这是实现定时任务的一种非常方便的方式。

不过，`time.Ticker`也存在一定的局限性。它的首次触发时间是从调用`time.NewTicker()`的那一刻开始计算的，这就意味着它无法精确对齐到某些特定时间点，比如：每个整点（如`8:00`）执行一次任务的场景，这类需求就不太适合使用`time.Ticker`来实现。

所以我们引入第三方库`cron`去完成这种定时任务的处理。

在讲解这个第三方库之前，先讲一下`cron`表达式的语法。`cron`表达式是一种字符串，用于指定定时任务的执行时间，`cron`表达式的基本语法包括`5`个或`6`个字段，每个字段之间用空格分隔，按照顺序排列，每个字段的含义如下：

```scss
    +------------ 秒[可选] (0 - 59)
    | +---------- 分钟 (0 - 59)
    | | +-------- 小时 (0 - 23)
    | | | +------ 日期 (1 - 31)
    | | | | +---- 月份 (1 - 12 或 JAN - DEC)
    | | | | | +-- 星期 (0 - 6 或 SUN - SAT, 其中 SUN = 0) 
    | | | | | |
    * * * * * *
```

如果是五个字段的`cron`表达式，通常是省略掉了秒字段，这是传统`Unix/Linux`系统上的默认`cron`实现，比如`crontab`，在这些系统上，如果使用六字段的`cron`表达式，可能会有报错。

同时`cron`每个字段的可选占位符都有以下几种：

1. `*`：表示所有合法值。例如在分钟域使用`*`，表示每分钟都会执行任务。
2. `,`：表示分隔多个枚举值。例如在小时域使用`1,2,3`，代表每天一点、两点、三点会执行任务。
3. `-`：表示范围。例如在日期域使用`1-5`，代表一号到五号会执行任务。
4. `/`：表示步长。例如在分钟域使用`*/5`，表示从第`0`分钟开始，每五分钟执行一次任务，若使用`2/5`，表示从第二分钟开始，每五分钟执行一次任务，也就是在每小时的第`2、7、12、17、22、27、32、37、42、47、52、57`分钟执行任务。
5. `?`：只能在日期或星期域中使用，用于表示“不指定具体的值”，主要目的是为了避免这两个字段同时指定时产生歧义。例如，表达式`0 0 12 15 * MON`含义不明确，可能被理解为“每月`15`号且是周一”时执行任务，也可能是“每月`15`号或每周一”时执行任务。为避免这种歧义，应使用`?`占位符来明确表达意图：`0 0 12 15 * ?`表示每月`15`号中午`12:00`执行任务，不关心星期几；`0 0 12 ? * MON`表示每周一中午`12:00`执行任务，不关心具体是哪一天。

讲完了`cron`表达式的基础语法，下面讲一下在项目中如何使用`cron`库完成定时任务的执行。首先下载`cron`库：

```sh
go get github.com/robfig/cron/v3
```

我们创建一个`cron`的实例：

```go
c := cron.New()
```

使用`cron`表达式添加定时任务：

```go
c.AddFunc("*/10 * * * *", func() {
	fmt.Println("Execute every 10 minutes")
})
```

这样创建的`cron`实例仅支持`5`字段的`cron`表达式，否则返回`error`：`expected exactly 5 fields, found 6`。

如果想支持`6`字段表达式，可以使用`cron.WithSeconds()`配置支持秒字段的解析器：

```go
c := cron.New(cron.WithSeconds())
```

这样，添加定时任务时就可以使用`6`字段的`cron`表达式：

```go
c.AddFunc("* */20 * * * *", func() {
	fmt.Println("Execute every 20 minutes")
})
```

其中`AddFunc`方法的方法签名如下所示：

```go
func (c *Cron) AddFunc(spec string, cmd func()) (EntryID, error)
```

`AddFunc`的第一个参数`spec`除了支持`cron`表达式，还支持时间间隔表达式`@every`，例如：

1. `@every 10s`：每十秒执行一次。
2. `@every 5m`：每五分钟执行一次。
3. `@every 1h`：每一小时执行一次。
4. `@every 2h30m`：每两小时三十分钟执行一次。
5. `@every 1d`：每一天执行一次。

使用方法如下所示：

```go
c.AddFunc("@every 1h", func() {
	fmt.Println("Execute every one hour")
})
```

> **注意：**使用`@every`表达式定义的是执行频率，计时从该定时任务执行的时刻开始。比如说定义时间间隔为`@every 1h`，该定时任务在`2024-06-28 11:18:05`开始执行，那么它的下次执行时间就是`2024-06-28 12:18:05`，以此类推。

除了标准的`cron`表达式和时间间隔表达式外，`github.com/robfig/cron/v3`还支持一些特殊关键字：

- `"@hourly"`：每小时执行一次，等同于`"0 * * * *"`。
- `"@daily"` 或 `"@midnight"`：每天执行一次，等同于`"0 0 * * *"`。
- `"@weekly"`：每周执行一次，等同于`"0 0 * * 0"`。
- `"@monthly"`：每月执行一次，等同于`"0 0 1 * *"`。
- `"@yearly"` 或 `"@annually"`：每年执行一次，等同于`"0 0 1 1 *"`。

```go
c.AddFunc("@daily", func() {
	fmt.Println("Execute every one day")
})
```

定义完所有的定时任务后，启动调度器：

```go
c.Start()
```

可以调用`Stop`方法，在需要时停止调度器，通常写在主函数的`defer`中：

```go
defer c.Stop()
```

除了`AddFunc`方法外，还可以使用`AddJob`方法将一个实现了`cron.Job`接口的结构体添加到调度器中：

```go
type MyJob struct {}

// 实现cron.Job接口的Run方法
func (m MyJob) Run() {
	fmt.Println("MyJob task running")
}
```

注册代码如下：

```go
c.AddJob("*/30 * * * *", MyJob{})
```

其中`AddJob`方法的方法签名如下：

```go
func (c *Cron) AddJob(spec string, cmd Job) (EntryID, error)
```

我们可以看到`AddFunc`和`AddJob`方法都有一个`EntryID`类型返回值，其中：`type EntryID int`，它是一个唯一标识符，用于标识每个添加到调度器中的任务，一般从`1`开始往下计数。获取`entryId`后，可以进行以下操作：

```go
// 获取对应任务具体信息，例如上次执行时间、下次执行时间等
entry := c.Entry(entryId)
nextTime := entry.Next
// 从调度器中删除对应任务
c.Remove(entryId)
```

`AddFunc`和`AddJob`方法都是异步非阻塞的方法，任务的执行在后台进行，不会影响主程序的执行。

在分布式部署场景下，定时任务容易出现重复执行的问题。在实际项目中，通常会将应用部署在多个实例上以实现负载均衡（例如使用`Nginx`+`Tomcat`集群，或者在`Kubernetes`中运行多个`Pod`）。当定时任务触发时，每个实例的调度器都会同时启动同一段任务逻辑，导致定时任务被重复执行，从而引发数据冗余或逻辑错误。

针对这种情况，可以使用`Redis`分布式锁进行控制。在任务执行前尝试加锁，只允许一个节点成功获取锁并执行任务，其他节点在检测到锁已被占用时，直接跳过任务执行。这样就能有效保证同一时刻只有一个节点执行定时任务，确保任务的幂等性，避免重复操作。