`cobra`是`Go`语言生态中常用的命令行程序构建库，可将其视为标准库`flag`的增强版。它提供结构化的命令、子命令、参数与标志管理机制，适合开发复杂的`CLI`工具，`kubelet`、`docker`等命令行工具均基于该库实现。

我们使用下面命令引入该库：

```sh
go get github.com/spf13/cobra
```

如果需要使用`cobra-cli`工具生成项目结构，可执行下面命令，安装命令行工具：

```sh
go install github.com/spf13/cobra-cli@latest
```

安装后，在指定目录执行`cobra-cli init`，快速初始化一个`CLI`项目。该命令会生成一个基础目录结构，如下：

```scss
.
├── cmd
│   └── root.go
└── main.go
```

在`main.go`文件中，仅在`main`函数内调用了`cmd.Execute()`。在该目录下可以执行如下命令编译程序：

```sh
go build -o app
```

这样即可编译出一个名为`app`的二进制可执行文件，后续将其放到某个`bin`目录，并加入环境变量`PATH`，即可直接执行。

在`root.go`中的代码内容如下所示：

```go
package cmd

import (
    "os"
    
    "github.com/spf13/cobra"
)

var rootCmd = &cobra.Command{
    Use:   "app",
    Short: "A brief description of your application",
    Long: `A longer description that spans multiple lines and likely contains
examples and usage of using your application. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.`,
    //Run: func(cmd *cobra.Command, args []string) { },
}

func Execute() {
    err := rootCmd.Execute()
    if err != nil {
       os.Exit(1)
    }
}

func init() {
    rootCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
}
```

参数`rootCmd`是一个`cobra.Command`类型的变量，其内部各字段的含义说明如下：

- `Use`：默认值为执行`cobra-cli init`命令时所在目录的目录名，用于定义命令的使用方式，即描述命令应如何被调用。
- `Short`：命令的简要描述，通常在父命令执行`--help`时，展示在其子命令列表中。对于`root`命令而言，由于其不存在父命令，该字段一般不会被展示；仅当未设置`Long`字段时，才会使用`Short`作为`Long`的替代说明。
- `Long`：命令的详细描述，通常在当前命令执行`--help`时展示，用于帮助用户更全面地理解该命令的用途和适用场景。
- `Run`：函数类型字段，用于定义命令被执行时实际运行的业务逻辑。其中，参数`cmd`表示当前命令对象，可通过它访问命令的`flags`及子命令等相关信息；参数`args`表示命令行中用户输入的，不包含`flags`的参数列表，

一般情况下，`root`命令不会实现`Run`函数，因为它通常仅作为命令树的顶层节点存在，本身不需要承载可直接执行的业务逻辑。但对于`root`命令，以及那些仍然包含子命令且自身不具备实际处理逻辑的子命令，可以在`RunE`中编写这行代码：

```go
RunE: func(cmd *cobra.Command, args []string) error {
	return cmd.Help()
},
```

这样，用户只执行`root`命令或者特定的子命令时，终端会自动展示对应的帮助列表，而无需用户显式地添加`--help`参数。

在`root.go`文件中，`Execute`函数内部调用`rootCmd.Execute()`，其作用是启动并执行整个`CLI`命令体系，是`cobra`应用的入口。

`Execute()`会从系统的`os.Args`变量中读取命令行输入，并对参数进行解析，包括子命令、`flag`及其取值。解析完成后，`cobra`能够确定用户实际调用的具体命令节点。`cobra`以`rootCmd`为根节点，在命令树中查找与用户输入最匹配的命令，如果存在多级子命令，则会逐层向下匹配，最终定位到需要执行的目标命令。

在完成合法性校验后，`Execute()`会调用该命令对应的`Run`或`RunE`函数，执行业务逻辑。同时，`Execute()`还会对执行过程中返回的错误进行统一处理，例如输出错误信息、展示帮助信息，并根据实际情况设置进程的退出码。

如果未调用`rootCmd.Execute()`，则`cobra`中定义的所有命令、子命令以及`flag`都不会生效，程序将直接退出。

在`root.go`文件的`init`函数里，有这样一行代码：

```go
rootCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
```

这行代码的作用是：为根命令`rootCmd`注册一个`bool`类型的命令行参数，用于在命令行中接收一个开关型配置。

`rootCmd.Flags()`返回的是当前命令的本地参数集合，也就是只对`rootCmd`本身生效，不会继承给子命令使用的参数。`BoolP`用于给当前命令新增一个布尔类型参数，其方法签名如下：

```go
func (f *FlagSet) BoolP(name, shorthand string, value bool, usage string) *bool
```

- `name`：表示参数的长名称，在命令行中使用形式为：`app --toggle`。
- `shorthand`：表示参数的短名称，在命令行中使用形式为：`app -t`。
- `value`：表示该参数的默认值，如果用户在命令行中未显式指定该参数，则其值为`false`。
- `usage`：表示该参数在执行`--help`时显示的帮助说明文本。

其他数据类型同理，例如`Int64P`、`Float64P`、`StringP`等，还有一类末尾不带`P`的方法表示不支持短名称。在输入带值的`flag`时，通常有两种等价写法，例如`--name=Mundo`与`--name Mundo`效果一致，同样地，`-n=Mundo`与`-n Mundo`也是等价的。

对于布尔类型的参数，通常支持省略显式取值的写法，例如`--toggle`等价于`--toggle=true`。

需要注意的是，短选项存在“组合”这一额外语法，这是长选项不具备的。例如：

```sh
app run -abc
```

这条命令等价于：

```sh
app run -a -b -c
```

但前提是`a`、`b`、`c`都必须是布尔类型的`flag`的简称，否则不能组合在一起使用。

我们通常会在命令的`Run`或`RunE`函数中读取该值，并进行使用，例如：

```go
Run: func(cmd *cobra.Command, args []string) {
    toggle, _ := cmd.Flags().GetBool("toggle")
    if toggle {
        // 开关开启时的逻辑
    }
},
```

这里通过`GetBool`方法获取用户为指定`flag`输入的值，参数需要传入该`flag`的完整名称。如果该`flag`不存在，或者其类型与当前要获取的类型不匹配，则会返回一个`err`。除布尔类型外，还有`GetString`、`GetInt64`、`GetFloat64`等其他类型的获取方法。

在实际的`CLI`工具开发中，单一的`root`命令往往无法满足需求。`cobra`通过命令树模型，将功能拆分为多个子命令，每个子命令对应一个相对独立的业务场景，例如`git commit`、`git pull`中的`commit`与`pull`。

在已通过`cobra-cli init`初始化的项目根目录下，可以使用如下命令创建一个子命令：

```
cobra-cli add serve
```

执行完成后，`cobra-cli`会在`cmd`目录下生成一个新的文件：

```scss
.
├── cmd
│   ├── root.go
│   └── serve.go
└── main.go
```

其中，`serve.go`即为新创建的子命令定义文件，其默认内容如下：

```go
package cmd

import (
	"fmt"

	"github.com/spf13/cobra"
)

var serveCmd = &cobra.Command{
	Use:   "serve",
	Short: "A brief description of your command",
	Long: `A longer description that spans multiple lines and likely contains examples
and usage of using your command. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.`,
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println("serve called")
	},
}

func init() {
	rootCmd.AddCommand(serveCmd)
}
```

在该文件的`init`函数中，有一行关键代码`rootCmd.AddCommand(serveCmd)`，该语句的作用是：将`serveCmd`注册为`rootCmd`的子命令，从而构建命令树结构。此后，我们即可通过如下方式调用该命令：

```sh
app serve
```

运行后，`serveCmd`在`Run`中配置的函数会被执行，并打印出`serve called`。

我们执行`app --help`，它会打印出如下内容：

```sh
A longer description that spans multiple lines and likely contains
examples and usage of using your application. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.

Usage:
  app [command]

Available Commands:
  completion  Generate the autocompletion script for the specified shell
  help        Help about any command
  serve       A brief description of your command

Flags:
  -h, --help     help for app
  -t, --toggle   Help message for toggle

Use "app [command] --help" for more information about a command.
```

这里，`Usage`中显示的`app`即为`rootCmd`的`Use`字段内容，`Available Commands`中显示的`serve`及其简要描述`A brief description of your command`，均是在`serveCmd`中定义的。

我们执行`app serve --help`，它会打印出如下内容：

```sh
A longer description that spans multiple lines and likely contains examples
and usage of using your command. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.

Usage:
  app serve [flags]

Flags:
  -h, --help   help for serve
```

这里显示的`Usage`是从根命令到当前命令的完整路径。同时我们注意到，根命令下定义的`toggle`在子命令中无法使用。

`Run`参数是无返回值的函数，适用于不需要向上层返回错误的简单场景。如果需要返回`error`，应使用`RunE`，当返回非`nil`的错误时，`cobra`会统一处理并输出错误信息。代码示例如下：

```go
var serveCmd = &cobra.Command{
    Use:   "serve",
    Short: "Start http server",
    RunE: func(cmd *cobra.Command, args []string) error {
        // 启动服务的逻辑
        return nil
    },
}
```

当这里的`RunE`函数返回`error`时，该错误会沿调用栈逐层向上传递，最终由`rootCmd.Execute()`统一处理。

除了`Run`函数，`cobra.Command`还提供了用于在命令执行前后插入前置与后置逻辑的函数：

- `PreRun`/`PreRunE`：当前命令级别的前置逻辑
- `PersistentPreRun`/`PersistentPreRunE`：可向子命令继承的前置逻辑
- `PostRun`/`PostRunE`：当前命令级别的后置逻辑
- `PersistentPostRun`/`PersistentPostRunE`：可向子命令继承的后置逻辑

假设父命令和子命令的相关钩子均已定义，则调用子命令时，整体执行顺序如下：

1. 父命令的`PersistentPreRun`
2. 子命令的`PersistentPreRun`
3. 子命令的`PreRun`
4. 子命令的`Run`
5. 子命令的`PostRun`
6. 子命令的`PersistentPostRun`
7. 父命令的`PersistentPostRun`

在子命令的`init`函数中，也可以定义其参数。除了使用`Flags()`定义的本地参数外，还可以使用`PersistentFlags()`定义持久参数，该参数会对当前命令及其所有子命令生效。

`cobra`支持任意层级的子命令嵌套。例如，可以在`serve`命令下再添加子命令：

```sh
cobra-cli add http --parent serveCmd
```

这里需要注意，`--parent`后面需要跟的是父命令对象的名称，而不是命令的使用名称。

执行完成后，项目结构会变为：

```scss
.
├── cmd
│   ├── root.go
│   ├── serve.go
│   └── http.go
└── main.go
```

新生成的`http.go`的默认代码内容如下所示：

```go
package cmd

import (
	"fmt"

	"github.com/spf13/cobra"
)

var httpCmd = &cobra.Command{
	Use:   "http",
	Short: "A brief description of your command",
	Long: `A longer description that spans multiple lines and likely contains examples
and usage of using your command. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.`,
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println("http called")
	},
}

func init() {
	serveCmd.AddCommand(httpCmd)
}
```

我们可以通过如下方式调用该命令：

```sh
app serve http
```

运行后，`httpCmd`在`Run`中配置的函数会被执行，并打印出`http called`。

使用`cobra`编写的`CLI`程序本质上是一个普通的可执行文件。每次在终端输入命令并回车时，操作系统都会启动一个新的进程，并从该进程的入口点开始执行，`main`函数以及所有`init`函数都会完整执行一次；当命令执行结束后，进程随即退出。
