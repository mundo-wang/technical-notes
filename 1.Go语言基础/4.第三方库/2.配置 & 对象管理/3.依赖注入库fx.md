`go.uber.org/fx`是`Uber`开源的一款基于`Go`语言的依赖注入（`Dependency Injection`，简称`DI`）与应用生命周期管理框架。它基于`dig`容器进行构建，在此之上进一步提供了模块化组织、生命周期钩子以及应用启动与关闭流程控制等能力，主要用于构建中大型、长期运行的服务型应用，例如`HTTP`服务、`RPC`服务以及后台任务系统等。

我们使用以下命令，引入`fx`这个依赖注入库：

```sh
go get go.uber.org/fx
```

我们先通过一个简单示例，对比说明不使用依赖注入与使用`fx`进行依赖注入这两种写法之间的差异。

例如现在有一个项目，其目录结构与文件分布如下：

```scss
.
├── app/
│   ├── router.go
│   └── handler.go
├── service/
│   └── user_service.go
├── infra/
│   └── db.go
└── main.go
```

其中`infra/db.go`的代码如下所示：

```go
func NewDB() (*gorm.DB, error) {
	// 省略数据库连接对象的初始化
	db := &gorm.DB{}
	return db, nil
}
```

`service/user_service.go`的代码如下所示：

```go
type UserService struct {
	db *gorm.DB
}

func NewUserService(db *gorm.DB) *UserService {
	return &UserService{db: db}
}
```

在不使用依赖注入的情况下，`app/handler.go`的代码如下所示：

```go
type UserHandler struct {
	userService *service.UserService
}

func NewUserHandler() *UserHandler {
	db, _ := infra.NewDB()
	userService := service.NewUserService(db)
	return &UserHandler{
		userService: userService,
	}
}

func (h *UserHandler) List(c *gin.Context) {
	c.JSON(200, gin.H{"users": []string{"Alice", "Bob", "Charlie"}})
}
```

接下来，`app/router.go`的代码内容如下所示：

```go
func RegisterRoutes(r *gin.Engine) {
	h := NewUserHandler()
	r.GET("/users", h.List)
}
```

`main.go`的代码内容如下所示：

```go
func main() {
	r := gin.New()
	app.RegisterRoutes(r)
	r.Run(":8080")
}
```

不使用依赖注入的核心问题主要体现在以下几点：

- 依赖关系被隐藏在子模块内部，仅阅读`main.go`无法判断是否使用数据库、启用了哪些`Service`以及初始化顺序。
- 分层被打穿，`Handler`层直接依赖`Infra`层，`HTTP`层感知基础设施，这在工程上属于不好的实现。
- 实现的替换成本高，变更基础设施（如更换数据库）只能修改`Handler`层业务代码，无法通过纯组装完成。

使用`fx`依赖注入仅调整职责划分，目录结构保持不变，`infra/db.go`与`service/user_service.go`的代码无需修改。

`app/handler.go`修改后的代码如下所示：

```go
type UserHandler struct {
	userService *service.UserService
}

func NewUserHandler(userService *service.UserService) *UserHandler {
	return &UserHandler{
		userService: userService,
	}
}
func (h *UserHandler) List(c *gin.Context) {
	c.JSON(200, gin.H{"users": []string{"Alice", "Bob", "Charlie"}})
}
```

`app/router.go`修改后的代码内容如下所示：

```go
func NewGinEngine() *gin.Engine {
	return gin.New()
}

func RegisterRoutes(r *gin.Engine, h *UserHandler) {
	r.GET("/users", h.List)
}

func StartHttpServer(lc fx.Lifecycle, r *gin.Engine) {
	lc.Append(fx.Hook{
		OnStart: func(ctx context.Context) error {
			go func() {
				_ = r.Run(":8080")
			}()
			return nil
		},
		OnStop: func(ctx context.Context) error {
			return nil
		},
	})
}
```

将`StartHttpServer`中`Gin`服务的启动与停止方式改为优雅启停，代码如下所示：

```go
func StartHttpServer(lc fx.Lifecycle, r *gin.Engine) {
	server := &http.Server{
		Addr:    ":8080",
		Handler: r,
	}
	lc.Append(fx.Hook{
		OnStart: func(ctx context.Context) error {
			go func() {
				_ = server.ListenAndServe()
			}()
			return nil
		},
		OnStop: func(ctx context.Context) error {
			_ = server.Shutdown(ctx)
			return nil
		},
	})
}
```

`main.go`修改后的代码内容如下所示：

```go
func main() {
	myApp := fx.New(
		fx.Provide(
			app.NewGinEngine,
			infra.NewDB,
			service.NewUserService,
			app.NewUserHandler,
		),
		fx.Invoke(
			app.RegisterRoutes,
			app.StartHttpServer,
		),
	)
	myApp.Run()
}
```

这样，`main.go`就成为一份依赖关系说明书，能够集中、清晰地呈现各组件之间的依赖链，结构明确且便于审查。

同时依赖方向被纠正：`Infra`层提供能力，`Service`层使用`Infra`，`Handler`层使用`Service`，`Router`层调用`Handler`，而`main`函数负责统一组装，避免任何越级依赖现象发生。

如果要替换数据库实现，例如将`MySQL`换成`PostgreSQL`，只需在`Infra`层新增一个获取`db`对象的方法，并在`main`函数的组装链中替换即可，`Service`层和`Handler`层代码无需修改。

`fx.Provide`用于向`fx`的`DI`容器（`dig`）注册构造函数，其函数签名如下：

```go
func Provide(constructors ...interface{}) Option
```

被`fx.Provide`注册的函数必须遵循以下约定：其所有参数均视为依赖项，并由容器自动注入；其返回值用于向容器提供对象。函数合法的返回形式包括`T`或`(T, error)`；当返回的`error`不为`nil`时，`fx`将直接终止应用的启动流程。

`fx.Provide`仅用于对象构造，其内部函数的执行顺序完全由依赖关系决定，与注册顺序无关。

`fx.Invoke`用于声明应用启动时必须执行的逻辑，其函数签名如下：

```go
func Invoke(funcs ...interface{}) Option
```

`fx.Invoke`声明的函数会在`fx.App`启动阶段被立即调用，`fx`会自动为这些函数注入所需依赖。在工程规范上，`Invoke`函数通常仅用于执行启动阶段的逻辑，一般返回`error`或不返回任何值，用于表示启动过程是否成功。如果某一个通过`fx.Invoke`声明的函数在启动阶段返回了非`nil`的`error`，`fx`会将其视为启动失败，并立即中断整个应用的启动流程，应用直接退出。

`fx.Invoke`的执行顺序与注册顺序一致，`fx`会按照我们在`fx.New`中声明`fx.Invoke`的先后顺序依次执行。

`fx.New`用于构建一个`fx.App`实例，其函数签名如下所示：

```go
func New(opts ...Option) *App
```

它本身并不启动应用，也不执行业务逻辑，其核心职责可以概括为：收集并解析所有`fx.Option`；构建依赖注入的`dig`容器；生成完整的应用启动与停止计划。从职责边界上看，`fx.New`仅负责装配应用蓝图，是蓝图生成器，而非应用启动器。

`fx.New`返回的`*fx.App`是一个可控的生命周期对象。调用`Run()`方法会触发完整的应用启动流程，其内部主要包含以下步骤：首先调用`Start`，触发所有通过`fx.Invoke`注册的函数，并启动生命周期管理；随后进入阻塞状态等待退出信号；在接收到退出信号后，调用`Stop`执行应用的优雅关闭流程。

在`Start`阶段，`fx`会对已注册的函数进行参数依赖解析；当发现依赖尚未创建时，会反向触发对应的`Provide`函数执行。待所有依赖准备完成后，才会调用具体的执行函数。本质上，`fx.Invoke`承担了驱动`Provide`执行的作用。

在`router.go`文件中新增了`StartHttpServer`方法。该方法是一组生命周期钩子，需要接收一个`fx.Lifecycle`类型的参数，它是`fx`内置提供的生命周期管理器，无需我们手动注入该依赖。该生命周期钩子也需注册到`fx.Invoke`中。

结构体`fx.Hook`的代码内容如下所示：

```go
type Hook struct {
	OnStart func(context.Context) error
	OnStop  func(context.Context) error

	onStartName string
	onStopName  string
}
```

其中，`OnStart`会在`fx.App.Start`阶段执行，发生在所有通过`Invoke`声明的函数完成调用、相关依赖由`Provide`构建完成之后、应用正式进入运行态之前。如果注册了多个`OnStart`，它们会严格按照在`fx.New`中声明的顺序执行。

由于`r.Run(":8080")`是阻塞调用，如果直接在`OnStart`中执行，启动流程会被阻塞，`fx`会认为应用尚未启动完成，因此需要使用`go`关键字创建协程来运行`Gin`服务。当`OnStart`返回非`nil`的`error`时，应用启动会失败，尚未执行的`OnStart`不会再执行，已经成功执行过的`OnStart`对应的`OnStop`会被调用，`Run`或`Start`方法会直接终止。

`OnStop`会在`fx.App.Stop`阶段执行，用于释放资源、关闭连接以及实现优雅停机。即便某个`OnStop`返回非`nil`的`error`，后续注册的`OnStop`仍会继续执行，从而保证资源的顺利释放、连接的顺利关闭。

`OnStop`的执行顺序遵循`LIFO`原则：按照`OnStart`成功执行顺序的逆序执行，即后启动的先关闭、先启动的后关闭。

`fx.Provide`、`fx.Invoke`和`OnStart`都可能返回`error`。如果需要集中获取错误并进行自定义处理，应使用`app.Start(ctx)`代替`Run()`，因为`Start`方法会返回`error`，可在调用方统一接收并处理。代码如下所示：

```go
func main() {
	myApp := fx.New(
		fx.Provide(
			app.NewGinEngine,
			infra.NewDB,
			service.NewUserService,
			app.NewUserHandler,
		),
		fx.Invoke(
			app.RegisterRoutes,
			app.StartHttpServer,
		),
	)
	err := myApp.Start(context.Background())
	if err != nil {
        // 这里无需手动调用Stop，因为已成功执行的OnStart对应的OnStop都会被调用
		fmt.Println("start failed:", err)
		os.Exit(1)
	}
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	err = myApp.Stop(context.Background())
	if err != nil {
		fmt.Println("stop completed with errors:", err)
	}
}
```

调用`Start`之后，应在适当时机调用`Stop`，否则生命周期钩子中的`OnStop`不会执行，资源无法被正确释放。由于单个`OnStop`返回的`error`不会阻止后续`OnStop`执行，如果存在多个错误，`Stop`方法返回的`error`通常是这些`error`的聚合值。

`fx.Invoke`在应用启动阶段执行时，如果发现所需依赖在容器中无法解析，或者依赖链中的任意依赖无法解析，应用启动会直接失败。`fx`会在`Start`阶段返回`error`，且应用不会进入运行状态。

前面我们一直使用的是`fx`最基础的依赖注入能力，也就是通过函数参数和返回值进行依赖声明与对象提供。这种方式在依赖关系简单、对象一进一出的场景下已经足够。但在实际工程中，经常会遇到以下两类问题：

1. 构造函数依赖过多，参数列表过长，可读性明显下降；
2. 一个构造函数需要同时提供多个对象，或者需要对同一类型进行区分注入。

为了解决这些问题，`fx`在`dig`的能力之上，引入了`fx.In`与`fx.Out`这两种结构化注入与输出机制。

假设`UserHandler`在后续演进中，不仅依赖`UserService`，还依赖日志组件和配置对象，代码如下所示：

```go
type HandlerParams struct {
	fx.In
	
	UserService *service.UserService
	Logger      *zap.Logger
}
```

此时，`Handler`的构造函数可以改写为：

```go
func NewUserHandler(h HandlerParams) *UserHandler {
	return &UserHandler{
		userService: h.UserService,
	}
}
```

需要注意的是，`fx.In`本身只是一个空结构体，用于标记该结构体的注入语义。结构体中的所有字段都会被视为依赖项，由`fx`根据字段类型从容器中解析并完成注入，从依赖声明的角度来看，这种写法相比冗长的参数列表更加直观，也更有利于后续的扩展与维护。

在工程实践中，某些依赖可能是“有则用、无则忽略”的，`fx.In`支持通过结构体标签声明可选依赖：

```go
type HandlerParams struct {
	fx.In
	
	UserService *service.UserService
	Logger      *zap.Logger `optional:"true"`
}
```

当容器中不存在`*zap.Logger`对象时，`fx`不会报错，而是向该字段注入`nil`。

`fx.In`不仅适用于`fx.Provide`中的构造函数，同样适用于`fx.Invoke`声明的启动函数，如下所示：

```go
type RegisterParams struct {
	fx.In

	Engine *gin.Engine
	Handler *UserHandler
}

func RegisterRoutes(p RegisterParams) {
	p.Engine.GET("/users", p.Handler.List)
}
```

`fx.Out`用于解决一个构造函数需要提供多个对象的问题。它允许通过结构体返回值，一次性向容器注册多个依赖。

在`fx`中，如果容器内注册了同一种类型的多个提供者，默认会产生冲突。`fx`会在启动阶段直接报错，提示该类型的依赖无法被唯一解析。若需要注册同一类型的多个实例，可以通过`fx.Out`并结合`name`字段对不同对象进行区分注册，从而避免类型冲突：

```go
type DBResult struct {
	fx.Out

	MySQLDB    *gorm.DB `name:"mysql"`
	PostgresDB *gorm.DB `name:"postgres"`
}

func NewDBs() (DBResult, error) {
	return DBResult{
		MySQLDB:    &gorm.DB{},
		PostgresDB: &gorm.DB{},
	}, nil
}
```

这样，可以在注入时通过`name`标签获取指定实例：

```go
type DBParams struct {
	fx.In

	MySQLDB *gorm.DB `name:"mysql"`
}
```

我们已经通过`fx.Provide`和`fx.Invoke`完成了依赖声明与应用组装。但随着项目规模的扩大，如果所有构造函数和启动逻辑都堆积在`main.go`中，`fx.New`的选项列表会迅速膨胀，可读性和可维护性都会显著下降。

为了解决装配逻辑过于集中的问题，`fx`提供了`fx.Module`，用于将一组高度相关的`fx.Option`进行模块化封装，从而实现更清晰的组织结构。`fx.Module`的核心作用可以概括为一句话：为一组依赖声明和启动逻辑提供清晰的边界和命名空间。

`fx.Module`的函数签名如下所示：

```go
func Module(name string, opts ...Option) Option
```

从类型上看，`fx.Module`返回的仍然是一个`fx.Option`类型对象，因此它可以直接传入`fx.New`，与`fx.Provide`、`fx.Invoke`并列使用，也可以嵌套在其他`fx.Module`中。

我们可以将与`HTTP`服务相关的内容整体收拢，而非分散在`main.go`中，可以在`app`目录下新增一个`module.go`文件，内容如下：

```go
func HttpModule() fx.Option {
	return fx.Module(
		"http",
		fx.Provide(
			NewGinEngine,
			NewUserHandler,
		),
		fx.Invoke(
			RegisterRoutes,
			StartHttpServer,
		),
	)
}
```

这时，`main.go`的代码可简化为如下所示：

```go
func main() {
	myApp := fx.New(
		fx.Provide(
			infra.NewDB,
			service.NewUserService,
		),
		app.HttpModule(),
	)
	myApp.Run()
}
```

通过这种方式，`HTTP`相关的构造函数和启动逻辑被完整封装在`HttpModule`内部，`main.go`只保留跨模块的组装关系，使整体结构更加清晰。需要注意的是，`fx.Module`并不会提供真正的作用域隔离。对于同一个由`fx.New`创建的`app`对象，所有通过`fx.Provide`注册的对象最终仍然进入同一个`dig`容器。模块名称用于逻辑分组和调试输出，而不是用来限制依赖的可见性。

在调试和排错场景中，`fx.Module`的`name`参数非常有用。当依赖无法解析或构造失败时，`fx`的`Start`方法返回的`error`会对原始`error`进行包装，并附带模块路径信息，从而帮助我们快速定位问题来源。

即使跨`fx.Module`，`fx.Invoke`的执行顺序仍然严格遵循`fx.New`中`Option`的展开顺序。`fx.Module`不会引入新的调度规则，它只是一个语义上的分组容器，内部会被原地展开。但是应注意，不应让两个`Invoke`之间存在强顺序依赖。
