`go.uber.org/fx`是`Uber`开源的一款基于`Go`语言的依赖注入（`Dependency Injection`，简称`DI`）与应用生命周期管理框架。它基于`dig`容器进行构建，在此之上进一步提供了模块化组织、生命周期钩子以及应用启动与关闭流程控制等能力，主要用于构建中大型、长期运行的服务型应用，例如`HTTP`服务、`RPC`服务以及后台任务系统等。

我们使用以下命令，引入`fx`这个依赖注入库：

```sh
go get go.uber.org/fx
```

我们先通过一个简单示例，对比说明不使用依赖注入与使用`fx`进行依赖注入这两种写法之间的差异。

例如现在有一个项目，其目录结构与文件分布如下：

```scss
.
├── app/
│   ├── router.go
│   └── handler.go
├── service/
│   └── user_service.go
├── infra/
│   └── db.go
└── main.go
```

其中`infra/db.go`的代码如下所示：

```go
func NewDB() (*gorm.DB, error) {
	// 省略数据库连接对象的初始化
	db := &gorm.DB{}
	return db, nil
}
```

`service/user_service.go`的代码如下所示：

```go
type UserService struct {
	db *gorm.DB
}

func NewUserService(db *gorm.DB) *UserService {
	return &UserService{db: db}
}
```

在不使用依赖注入的情况下，`app/handler.go`的代码如下所示：

```go
type UserHandler struct {
	userService *service.UserService
}

func NewUserHandler() *UserHandler {
	db, _ := infra.NewDB()
	userService := service.NewUserService(db)
	return &UserHandler{
		userService: userService,
	}
}

func (h *UserHandler) List(c *gin.Context) {
	c.JSON(200, gin.H{"users": []string{"Alice", "Bob", "Charlie"}})
}
```

接下来，`app/router.go`的代码内容如下所示：

```go
func RegisterRoutes(r *gin.Engine) {
	h := NewUserHandler()
	r.GET("/users", h.List)
}
```

`main.go`的代码内容如下所示：

```go
func main() {
	r := gin.New()
	app.RegisterRoutes(r)
	r.Run(":8080")
}
```

不使用依赖注入的核心问题主要体现在以下几点：

- 依赖关系被隐藏在子模块内部，仅阅读`main.go`无法判断是否使用数据库、启用了哪些`Service`以及初始化顺序。
- 分层被打穿，`Handler`层直接依赖`Infra`层，`HTTP`层感知基础设施，这在工程上属于不好的实现。
- 实现的替换成本高，变更基础设施（如更换数据库）只能修改`Handler`层业务代码，无法通过纯组装完成。

使用`fx`依赖注入仅调整职责划分，目录结构保持不变，`infra/db.go`与`service/user_service.go`的代码无需修改。

`app/handler.go`修改后的代码如下所示：

```go
type UserHandler struct {
	userService *service.UserService
}

func NewUserHandler(userService *service.UserService) *UserHandler {
	return &UserHandler{
		userService: userService,
	}
}
func (h *UserHandler) List(c *gin.Context) {
	c.JSON(200, gin.H{"users": []string{"Alice", "Bob", "Charlie"}})
}
```

`app/router.go`修改后的代码内容如下所示：

```go
func RegisterRoutes(r *gin.Engine, h *UserHandler) {
	r.GET("/users", h.List)
}

func StartHttpServer(lc fx.Lifecycle, r *gin.Engine) {
	lc.Append(fx.Hook{
		OnStart: func(ctx context.Context) error {
			go func() {
				_ = r.Run(":8080")
			}()
			return nil
		},
		OnStop: func(ctx context.Context) error {
			return nil
		},
	})
}
```

`main.go`修改后的代码内容如下所示：

```go
func NewGinEngine() *gin.Engine {
	return gin.New()
}

func main() {
	fx.New(
		fx.Provide(
			NewGinEngine,
			infra.NewDB,
			service.NewUserService,
			app.NewUserHandler,
		),
		fx.Invoke(
			app.RegisterRoutes,
			app.StartHttpServer,
		),
	).Run()
}
```

这样，`main.go`就成为一份依赖关系说明书，能够集中、清晰地呈现各组件之间的依赖链，结构明确且便于审查。

同时依赖方向被纠正：`Infra`层提供能力，`Service`层使用`Infra`，`Handler`层使用`Service`，`Router`层调用`Handler`，而`main`函数负责统一组装，避免任何越级依赖现象发生。

如果要替换数据库实现，例如将`MySQL`换成`PostgreSQL`，只需在`Infra`层新增一个获取`db`对象的方法，并在`main`函数的组装链中替换即可，`Service`层和`Handler`层代码无需修改。

`fx.Provide`用于向`fx`的`DI`容器（`dig`）注册构造函数，其函数签名如下：

```go
func Provide(constructors ...interface{}) Option
```

被`fx.Provide`注册的函数必须遵循以下约定：其所有参数均视为依赖项，并由容器自动注入；其返回值用于向容器提供对象。函数合法的返回形式包括`T`或`(T, error)`；当返回的`error`不为`nil`时，`fx`将直接终止应用的启动流程。

`fx.Provide`仅用于对象构造，其内部函数的执行顺序完全由依赖关系决定，与注册顺序无关。

`fx.Invoke`用于声明应用启动时必须执行的逻辑，其函数签名如下：

```go
func Invoke(funcs ...interface{}) Option
```

待办
