逃逸（`Escape`）通常指变量或对象的生命周期延长至超出其原始作用域。在`Go`语言中，每个函数调用会分配一个栈帧，用于存储局部变量、参数和返回地址。当函数返回时，栈帧被销毁，所有的内存被释放。然而，发生逃逸意味着局部变量在函数结束后依然被引用，导致这些变量的存储从栈逃逸到堆上，其生命周期延长到函数外部。这样，逃逸的局部变量就需要垃圾回收器来进行回收。

一段发生了局部变量逃逸的代码示例如下所示：

```go
func createPointer() *int {
	x := 42
	return &x // 返回一个指向局部变量的指针
}

func main() {
	pointer := createPointer() // 调用 createPointer 函数，得到一个指向局部变量的指针
	fmt.Println(*pointer)
}
```

函数`createPointer`创建了一个局部变量`x`，并返回指向该局部变量的指针。在`main`函数中，我们调用`createPointer`函数，获取这个指针并打印其指向的值。

逃逸分析的作用是分析变量`x`是否发生逃逸。在上面的例子中，逃逸分析器会发现局部变量`x`的生命周期已经逃逸到了`main`函数中，因为即便`createPointer`函数已经执行完毕，`main`函数仍然可以引用并使用这个指针。因此，逃逸分析器会将局部变量`x`分配在堆上，以确保在`main`函数中可以安全地引用它。

如果逃逸分析器确定局部变量没有发生逃逸，那么它会继续分配在栈上。逃逸分析的结果会影响编译器的内存优化策略。通过将不逃逸的变量分配在栈上，可以避免不必要的堆分配，从而提高程序的性能。而如果变量发生逃逸，堆分配则确保变量在函数返回后仍然可用。

逃逸的类型有以下两种：

- 栈逃逸：当一个局部变量在函数内部被声明和分配，但其引用传递到了函数外部（例如返回该局部变量的引用），这称为栈逃逸。编译器可能会将这个变量的存储位置从栈移动到堆，以确保变量在函数返回后仍然有效，即其生命周期延长到函数外部。
- 堆逃逸： 堆逃逸指的是一个变量被分配在堆上，但其引用没有离开分配它的函数。在这种情况下，编译器可能会将变量分配在栈上，以避免堆分配的开销和垃圾回收的负担。堆逃逸的优化可以减少不必要的堆分配，提升程序的内存使用效率和性能。

逃逸分析后，优化目标如下：

- 减少堆分配： 将一些对象分配在栈上而不是堆上，可以减少垃圾回收的负担。栈上的对象在函数返回时会自动释放，不需要额外的回收操作。减少堆分配可以提高程序的运行效率和响应速度。
- 减少锁的竞争： 在并发程序中，对象的分配位置可以影响锁的竞争情况。如果对象分配在栈上，那么对该对象的操作在多线程环境下可能不需要锁保护，因为每个线程操作的是自己的栈上副本，不会相互干扰。逃逸分析可以帮助减少对共享资源的争夺，提高并发程序的性能和可伸缩性。

总结来说，逃逸分析的优化目标是尽可能多地将对象分配到栈上。