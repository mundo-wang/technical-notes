`Go`语言中的数组和切片是两个不同的概念，各自有其特点和用途。下面详细讲解它们的区别。

### 1. 数组 （`array`）

数组是一个定长的序列，用于存储同一种类型的元素。在定义时需要指定长度，且该长度一旦确定就不可改变。数组的长度是其类型的一部分，例如`[3]int`类型和`[5]int`类型是不同的数据类型。数组是值类型，这意味着在赋值或传递时，会拷贝整个数组。数组在内存中占据一块连续的空间，其大小在编译时确定，并且一旦分配好就不会再更改。

初始化数组时，可以使用以下几种方式：

```go
var arr [5]int                 // 声明一个长度为5的int数组，默认值为0
arr := [5]int{1, 2, 3, 4, 5}   // 声明并初始化一个长度为5的int数组
arr := [...]int{1, 2, 3, 4, 5} // 根据初始化元素个数，自动推断数组长度
```

只要数组的元素类型可比较，数组本身也就可比较。编译器会逐个比较元素，只有所有元素都相等时，数组才相等。

### 2. 切片 （`slice`）

切片是对底层数组的一个连续片段的引用，它由指向底层数组的指针、切片的长度和容量三部分组成：

```go
type slice struct {
	ptr unsafe.Pointer // 指向底层数组的指针
	len int            // 切片的长度
	cap int            // 切片的容量
}
```

在`Go`语言中，切片的长度可以通过`append`函数动态增长。当切片的容量不足以容纳新增元素时，运行时会触发扩容机制：创建一个更大容量的底层数组，并将原数组的数据复制到新数组中。扩容策略取决于当前切片的容量：

- 当容量小于或等于`1024`时，通常按原容量的两倍扩容；
- 当容量大于`1024`时，通常按原容量的`1.25`倍扩容，以降低内存浪费。

如果通过`append`追加的元素较多（例如追加一个较大的切片），而扩容后计算出的新容量仍不足以容纳所有元素，`Go`会直接将新容量设置为能够容纳全部元素的最小容量。由于扩容涉及内存分配和数据复制，开销较高，因此在已知大致所需容量的情况下，建议使用`make`函数提前分配足够的容量，例如：`make([]int, 0, 1000)`，以减少扩容次数，提升性能。

切片的零值是`nil`，这意味着一个未初始化的切片为`nil`，且其长度和容量均为`0`。需要注意的是，`nil`切片和空切片是不同的。空切片是一个合法的切片，虽然它的长度和容量都是`0`，但它并不是`nil`：

```go
var nilSlice []int
fmt.Println(nilSlice == nil) // 输出：true
emptySlice := []int{}
fmt.Println(emptySlice == nil) // 输出：false
```

初始化切片时，可以使用以下几种方式：

```go
// 1. 直接声明和初始化（长度和容量均为当前切片元素个数）
slice1 := []int{1, 2, 3, 4, 5}

// 2. 使用make函数创建（参数2为长度，参数3为容量，长度不得大于容量。如果只有参数2，长度和容量都是它）
slice2 := make([]int, 3, 5)

// 3. 通过数组或切片的切片操作创建新切片
arr := [5]int{1, 2, 3, 4, 5}
slice3 := arr[1:4] // 获取arr的第2到第4个元素

// 4. 使用append函数动态添加元素
slice4 := []int{}
slice4 = append(slice4, 1, 2, 3)

// 5. 使用copy函数复制切片
source := []int{1, 2, 3}
slice5 := make([]int, len(source))
copy(slice5, source)
```

切片的长度是实际包含的元素数量，容量是切片底层数组的大小，可以分别用以下两个函数获取：

```go
slice := make([]int, 3, 5)
fmt.Println(len(slice)) // 3
fmt.Println(cap(slice)) // 5
```

使用`make`函数创建切片并指定长度时，切片中的每个元素都会被初始化为其类型的零值。此外，只有通过`make`函数才能显式指定切片的容量，例如：`make([]int, 5, 10)`，其中长度为`5`，容量为`10`。相比之下，如果使用字面量定义切片（如：`[]int{1, 2, 3}`），切片的长度和容量将根据提供的元素数量自动推算，二者相等，无法单独指定容量。

作为引用类型，多个切片可以共享同一个底层数组，这意味着修改其中一个切片的元素可能会影响到其他切片，如下所示：

```go
arr := []int{1, 2, 3, 4, 5}
slice1 := arr[1:4]
slice2 := arr[2:5]
slice1[2] = 99
fmt.Println(slice1) // [2 3 99]
fmt.Println(slice2) // [3 99 5]
```

切片在作为函数参数传递时，函数接收到的是切片底层数组的指针（`ptr`）以及元数据（`len`与`cap`）的副本，而非底层数组本身的完整拷贝，因此切片在传递时的开销较小。若在函数内部修改了切片中的某个元素，外部能够看到变化：

```go
func modifyElement(s []string) {
	s[2] = "f"
}

func main() {
	s := []string{"a", "b", "c", "d", "e"}
	addElement(s)
	fmt.Println(s)
}
```

运行程序，打印结果为`[a b f d e]`。

但是若在方法中对切片进行了`append`操作，情况会有些不同，例如下面代码：

```go
func addElement(s []string) {
	s = append(s, "f")
}

func main() {
	s := []string{"a", "b", "c", "d", "e"}
	addElement(s)
	fmt.Println(s)
}
```

运行程序，打印结果为`[a b c d e]`。这是因为切片的本质是由指针、长度、容量组成的结构体。当切片`s`被传入函数`addElement`时，传入的是这三个字段的拷贝。在示例中，`addElement`中的切片`s`的`cap`为`5`，当需要追加新元素`f`时，原有容量不足，`append`会创建新的底层数组并拷贝原内容，也就是切片扩容。这样，函数内部的`s`会指向新的底层数组，且`len`变为`6`；而函数外的`s`依旧指向原来的底层数组，且`len`与`cap`保持不变，因此最终输出仍为原有内容。

那么如果在创建切片时设置了足够大的容量呢？例如以下代码：

```go
func addElement(s []string) {
	s = append(s, "f")
}

func main() {
	s := make([]string, 0, 10)
	s = append(s, "a", "b", "c", "d", "e")
	addElement(s)
	fmt.Println(s)
}
```

运行程序后仍然输出`[a b c d e]`。这是因为，函数`addElement`内部的切片`s`在执行`append`后长度已经变为`6`，但函数外的切片`s`仍然保持长度`5`，因此即使函数内外的`ptr`指向同一个底层数组，外部打印时只会输出其`len`范围内的元素。

若希望外部也看到新元素，必须让函数返回新的切片，并在外部接收，代码如下：

```go
func addElement(s []string) []string {
	s = append(s, "f")
	return s
}

func main() {
	s := make([]string, 0, 10)
	s = append(s, "a", "b", "c", "d", "e")
	s = addElement(s)
	fmt.Println(s)
}
```

由此可以得出结论：如果在函数内部改动了传入切片的`ptr`、`len`或`cap`，函数外部的变量无法感知到，必须依赖返回值进行传递；而若函数内部仅修改了切片底层数组的内容，而未改变切片的三要素，函数外部的变量可以感知到这些变化。
