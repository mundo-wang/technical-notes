### 1. `make`函数

`make`函数专门用于在`Go`语言中创建和初始化`slice`、`map`和`channel`，并返回对应类型的实例，而不是指针，因为这三种类型本身已经是引用类型。`make`会为它们分配内存，并设置合适的初始状态。

语法结构：`make(T, args...)`，其中`T`是切片、映射或通道的类型，`args`是相应类型的初始化参数。创建示例如下：

```go
mySlice := make([]int, 5, 10)    // 切片初始长度为5，容量为10
myMap := make(map[string]int, 5) // 映射初始长度为5
myChannel := make(chan int, 3)   // 创建缓冲区长度为3的有缓冲信道
```

创建`slice`时必须提供一个或两个参数；创建`map`和`channel`时最多只能提供一个参数，也可以不提供参数。

> **注意：**由于`slice`、`map`和`channel`本身即为引用类型，所以不可以使用`new`函数来创建它们的实例。

切片`mySlice`中每个元素都被初始化为该类型的零值，由于`int`类型的零值为`0`，所以上面`mySlice`的初始状态是`[0, 0, 0, 0, 0]`。映射`myMap`在创建时为空，不包含任何键值对，但它是一个有效的`map`对象，并不是`nil`。`myChannel`同理，有缓冲通道在创建时为空，无缓冲通道没有元素存储空间，但它们都不是`nil`。

在`Go`语言中，通道是可比较的对象。通道的比较方式类似指针比较，即判断它们是否引用同一个通道对象。通道本质上是管道而非容器，因此不会有人期望比较其中的数据，也不会关心缓冲区长度是否一致，通道只具备“相同/不同”的语义。

切片和映射虽然都是引用类型，但它们不能直接比较是否相等。切片本质上是一个包含`ptr`、`len`、`cap`三个字段的结构体，如果允许使用`==`比较，就意味着需要同时比较这三个字段。但程序员通常关心的是切片是否指向同一个底层数组，或切片的内容是否相同，而非长度或容量。这容易产生歧义，因此语言层面禁止了切片比较。

映射的底层实现更复杂，包含哈希桶和随机化种子等。如果允许`==`比较，就需要明确“相等”的语义：是判断两个变量是否指向同一张哈希表，还是比较哈希表中所有键值对是否相等。由于语义不明确且实现成本高，`Go`语言选择不支持映射的直接比较。

### 2. `new`函数

`new`用于为一个类型分配内存，并返回该类型的指针，指针的类型为`*T`（其中`T`是类型）。分配的内存空间会初始化为该类型的零值。例如，`int`类型的零值为`0`，`string`类型的零值为空字符串。

> **注意：**对于结构体类型对象，它的零值意味着所有字段都会被初始化为各自类型的零值。

```go
type Person struct {
	Name string
	Age  int
}

func main() {
	p := new(Person)
	p1 := &Person{}
	var p2 *Person

	fmt.Println(p.Name, p.Age)   // "" 0
	fmt.Println(p1.Name, p1.Age) // "" 0
	// panic: runtime error: invalid memory address or nil pointer dereference
	fmt.Println(p2.Name, p2.Age)
}
```

在上面的代码示例中：

1. `p`和`p1`的效果完全相同，都是创建一个`Person`结构体并返回其指针。访问该实例的属性时，将返回该属性类型的零值。
2. `p2`的行为与前两个不同。使用`var`声明一个指针类型对象但未分配内存时，`p2`的值为`nil`，即指针为空，此时访问其内部属性会导致空指针异常。而如果使用`var`声明的是值类型对象，则该对象会被初始化为其零值。

如果结构体`Person`内有一个嵌套结构体（无论是命名嵌套还是匿名嵌套），如下所示：

```go
type Address struct {
	Name string
}

type Person struct {
	Name    string
	Age     int
	Address Address
}
```

使用`new(Person)`或`&Person{}`创建对象时，会自动为其内部嵌套的结构体`Address`分配零值，并将其赋给`Person`结构体中的`Address`字段。因此，访问`Address`字段的内部字段时不会出现空指针异常：

```go
fmt.Println(p.Name, p.Age, p.Address.Name)   // "" 0 ""
fmt.Println(p1.Name, p1.Age, p.Address.Name) // "" 0 ""
```

但如果`Person`结构体中`Address`字段的类型为`*Address`，或将`*Address`作为匿名嵌套结构体，则`Address`字段的值将为`nil`，此时访问其内部字段会导致空指针异常。

`new`也可以用于分配基础数据类型或其别名的内存，例如以下代码：

```go
type MyInt int

func main() {
	num1 := new(MyInt)
	num2 := new(int)
	fmt.Println(*num1, *num2)  // 0 0
}
```

在这个例子中，`new(MyInt)`和`new(int)`分别分配了`MyInt`和`int`类型的内存，并返回指向它们的指针。由于`MyInt`是`int`的别名，它的零值也是`0`，所以打印结果是`0 0`。
