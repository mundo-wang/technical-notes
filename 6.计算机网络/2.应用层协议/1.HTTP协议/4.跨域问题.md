跨域问题是指在网页浏览器中，出于安全考虑，浏览器会禁止某个网页向不同域名的后端服务器发起请求。这种限制机制被称为同源策略（`Same-Origin Policy`，`SOP`），其主要目的是防止恶意网站通过脚本窃取用户的敏感信息。

同源策略要求前端页面与后端服务器在以下三个方面完全一致，才能发送请求：

1. 协议（`Protocol`）：`http`与`https`属于不同源。例如：`http://example.com`与`https://example.com`。
2. 域名（`Host`）：必须完全相同，否则属于不同源。例如：`https://example.com`与`https://api.example.com`。
3. 端口（`Port`）：端口号不同也视为不同源。例如：`https://example.com:443`与`https://example.com:3443`。

同源策略的检查只看协议、域名和端口（`HTTPS`默认为`443`）是否一致，不会检查路径。例如下面情况属于同源：

- 页面地址：`https://example.com/index`。

- 接口地址：`https://example.com/api/v1/resource`。

同源策略是由浏览器强制执行的一种安全机制，所有主流浏览器（如`Chrome`、`Firefox`、`Safari`、`Edge`等）都遵循该规范。

当网页尝试发起跨域请求且该请求不属于简单请求时，浏览器会在实际请求之前自动向服务器发送一次`OPTIONS`预检请求，用于确认服务器是否允许本次跨域访问。概括而言，`OPTIONS`请求的目的就是在正式发送非简单跨域请求之前，提前向服务器确认该请求是否被允许，从而避免实际请求直接执行而对服务器产生不可预期的副作用。

预检`OPTIONS`请求会把正式请求中可能影响跨域安全的关键元素以专门的预检头的形式发送给服务器，具体而言：

- `Origin`：表示请求发起的源，也就是协议 + 域名 + 端口，例如：`https://example.com:3443`。
- `Access-Control-Request-Method`：表示正式请求打算使用的方法（如`PUT`、`DELETE`等）。
- `Access-Control-Request-Headers`：表示正式请求中使用的自定义请求头或者不在“简单请求头”列表里的头部。

简单请求需要满足以下三个条件：

1. 请求方法必须是以下三种之一：`GET`、`POST`、`HEAD`。
2. 只能包含浏览器自动设置的几种头部，也就是说不能添加任何自定义请求头（例如`Authorization`）。
3. 如果请求方法是`POST`，那么它的`Content-Type`必须是下面这三种之一：`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`。注意，`application/json`不算简单请求。

解决跨域问题有多种方法，我们这里只对`CORS`方法进行讲解。`CORS`（`Cross-Origin Resource Sharing`，跨域资源共享）是一种标准机制，用于声明服务器允许哪些域名跨域访问资源。通过在服务器响应头中设置合适的字段，可以允许特定的跨域请求。

后端服务器可以通过在响应头设置`Access-Control-Allow-Origin`参数，允许某个前端域名的跨域请求。例如：

```http
Access-Control-Allow-Origin: https://example.com
```

在测试环境中，可以设置允许所有域名的跨域请求：

```http
Access-Control-Allow-Origin: *
```

除了上面的响应头外，还有其他这些`CROS`响应头可以设置：

- `Access-Control-Allow-Methods`：指定允许的`HTTP`方法，如`GET`、`POST`等。
- `Access-Control-Allow-Headers`：指定允许的请求头字段。
- `Access-Control-Allow-Credentials`：允许发送认证信息（如`Authorization`）。
- `Access-Control-Max-Age`：指定预检`OPTIONS`请求的结果可以被缓存多长时间。

需要注意的是，如果请求携带了`Token`，`Access-Control-Allow-Origin`就不能设置为`*`，必须指定具体的域名。

浏览器在收到正式请求的响应后，会根据响应头中的`CORS`规则进行校验。如果校验未通过，浏览器会阻止前端`JavaScript`访问响应数据，即使服务器已返回响应内容。因此，预检`OPTIONS`请求对于非简单请求至关重要，因为服务端通常不会在非`OPTIONS`请求阶段进行跨域校验，即使请求不符合`CORS`规则，业务逻辑仍会被执行，只有响应返回浏览器后才会被拦截。

我们需要注意，简单请求仅表示不会触发预检请求，并不意味着它不受跨域限制。简单请求能够成功完成跨域访问，本质上仍然依赖服务器返回正确的`CORS`响应头，只是浏览器在这一过程中省略了预检阶段。

在`Gin`框架中，我们可以编写一个如下所示的跨域中间件，用于解决跨域问题：

```go
func CorsMiddleware(c *gin.Context) {
    // 对预检OPTIONS请求进行判断处理，并截断请求不进入后续中间件与业务逻辑
	if c.Request.Method == http.MethodOptions {
		origin := c.GetHeader("Origin")
		reqMethod := c.GetHeader("Access-Control-Request-Method")
		reqHeaders := c.GetHeader("Access-Control-Request-Headers")
		if !checkOrigin(origin) || !checkMethod(reqMethod) || !checkHeaders(reqHeaders) {
			c.AbortWithStatus(http.StatusForbidden)
			return
		}
		c.Header("Access-Control-Allow-Origin", origin)
		c.Header("Access-Control-Allow-Credentials", "true")
		c.Header("Access-Control-Allow-Headers", "Content-Type, Content-Length, Authorization")
		c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, OPTIONS")
		c.Header("Access-Control-Max-Age", "86400")
		c.AbortWithStatus(http.StatusNoContent)
		return
	}
    // 对正式请求，返回指定的响应头，交由浏览器进行判断处理
    c.Header("Access-Control-Allow-Origin", "https://example.com")
	c.Header("Access-Control-Allow-Credentials", "true")
	c.Header("Access-Control-Allow-Headers", "Content-Type, Content-Length, Authorization")
	c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, OPTIONS")
	c.Header("Access-Control-Max-Age", "86400")
	c.Next()
}
```

我们也可以使用第三方库来简化跨域中间件的编写：

```sh
go get github.com/gin-contrib/cors
```

如果想允许所有的跨域请求，可以直接使用`cors`库默认的`Default`函数：

```go
r.Use(cors.Default())
```

其内部源码是通过以下方式进行配置的：

```go
func Default() gin.HandlerFunc {
	config := DefaultConfig()
	config.AllowAllOrigins = true
	return New(config)
}

func DefaultConfig() Config {
	return Config{
		AllowMethods:     []string{"GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS"},
		AllowHeaders:     []string{"Origin", "Content-Length", "Content-Type"},
		AllowCredentials: false,
		MaxAge:           12 * time.Hour,
	}
}
```

如果需要更严格的控制，可以根据需要自定义`CORS`设置。例如：

```go
router.Use(cors.New(cors.Config{
    AllowOrigins: []string{"https://example.com"}, // 允许来自特定前端域名的请求
    AllowMethods: []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
    AllowHeaders: []string{"Origin", "Content-Type", "Authorization"},
}))
```

在`cors.New`函数中，包含了对`OPTIONS`请求的判断逻辑，同时会设置状态码为`204`，并中止后续的处理流程。

除此之外，我们还可以通过在`Nginx`的配置文件中设置`proxy_pass`指令，将来自前端的请求转发到真实的后端服务地址。由于该转发过程是在服务器端完成的，浏览器只会看到自己向同源的`Nginx`服务器发起了请求，因此不会触发跨域限制。
