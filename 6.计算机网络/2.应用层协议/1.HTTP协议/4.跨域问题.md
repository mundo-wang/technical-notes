跨域问题是指在网页浏览器中，出于安全考虑，浏览器会禁止某个网页向不同域名的后端服务器发起请求。这种限制机制被称为同源策略（`Same-Origin Policy`，`SOP`），其主要目的是防止恶意网站通过脚本窃取用户的敏感信息。

同源策略要求前端页面与后端服务器在以下三个方面完全一致，才能发送请求：

1. 协议（`Protocol`）：`http`与`https`属于不同源。例如：`http://example.com`与`https://example.com`。
2. 域名（`Host`）：必须完全相同，否则属于不同源。例如：`https://example.com`与`https://api.example.com`。
3. 端口（`Port`）：端口号不同也视为不同源。例如：`https://example.com:8080`与`https://example.com:8090`。

同源策略的检查只看协议、域名和端口（`HTTPS`默认为`443`）是否一致，不会检查路径。例如下面情况属于同源：

- 页面地址：`https://example.com/index`。

- 接口地址：`https://example.com/api/v1/resource`。

同源策略是由浏览器强制执行的一种安全机制，所有主流浏览器（如`Chrome`、`Firefox`、`Safari`、`Edge`等）都遵循该规范。

当网页尝试发起跨域请求且该请求不属于简单请求时，浏览器会在实际请求之前自动向服务器发送一次`OPTIONS`预检请求，用于确认服务器是否允许本次跨域访问。概括而言，`OPTIONS`请求的目的就是在正式发送非简单跨域请求之前，提前向服务器确认该请求是否被允许，从而避免实际请求直接执行而对服务器产生不可预期的副作用。

简单请求需要满足以下三个条件：

1. 请求方法必须是以下三种之一：`GET`、`POST`、`HEAD`。
2. 只能包含浏览器自动设置的几种头部，也就是说不能添加任何自定义请求头（例如`Authorization`）。
3. 如果请求方法是`POST`，那么它的`Content-Type`必须是下面这三种之一：`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`。注意，`application/json`不算简单请求。

解决跨域问题有多种方法，我们这里只对`CORS`方法进行讲解。`CORS`（`Cross-Origin Resource Sharing`，跨域资源共享）是一种标准机制，用于声明服务器允许哪些域名跨域访问资源。通过在服务器响应头中设置合适的字段，可以允许特定的跨域请求。

后端服务器可以通过在请求头设置`Access-Control-Allow-Origin`参数，允许某个前端域名的跨域请求。例如：

```http
Access-Control-Allow-Origin: https://example.com
```

在测试环境中，可以设置允许所有域名的跨域请求：

```http
Access-Control-Allow-Origin: *
```

除了上面的响应头外，还有其他这些`CROS`响应头可以设置：

- `Access-Control-Allow-Methods`：指定允许的`HTTP`方法，如`GET`、`POST`等。
- `Access-Control-Allow-Headers`：指定允许的请求头字段。
- `Access-Control-Allow-Credentials`：允许发送认证信息（如`Cookie`）。
- `Access-Control-Max-Age`：指定预检请求（`OPTIONS`请求）的结果可以被缓存多长时间。

在`Gin`框架中，我们可以编写一个如下所示的跨域中间件，用于解决跨域问题：

```go
func CorsMiddleware(c *gin.Context) {
	c.Header("Access-Control-Allow-Origin", "*")
	c.Header("Access-Control-Allow-Credentials", "false")
	c.Header("Access-Control-Allow-Headers", "Content-Type, Content-Length, Authorization")
	c.Header("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT")
	c.Header("Access-Control-Max-Age", "86400")
	// 如果是预检请求（OPTIONS），直接返回204状态码，表示允许跨域，并终止后续处理
	if c.Request.Method == http.MethodOptions {
		c.AbortWithStatus(http.StatusNoContent)
		return
	}
	c.Next()
}
```

需要注意的是，简单请求仅表示不会触发预检请求，并不意味着它不受跨域限制。简单请求能够成功完成跨域访问，本质上仍然依赖服务器返回正确的`CORS`响应头，只是浏览器在这一过程中省略了预检阶段。

我们也可以使用第三方库来简化跨域中间件的编写：

```sh
go get github.com/gin-contrib/cors
```

如果想允许所有的跨域请求，可以直接使用`cors`库默认的`Default`函数：

```go
r.Use(cors.Default())
```

其内部源码是通过以下方式进行配置的：

```go
func Default() gin.HandlerFunc {
	config := DefaultConfig()
	config.AllowAllOrigins = true
	return New(config)
}

func DefaultConfig() Config {
	return Config{
		AllowMethods:     []string{"GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS"},
		AllowHeaders:     []string{"Origin", "Content-Length", "Content-Type"},
		AllowCredentials: false,
		MaxAge:           12 * time.Hour,
	}
}
```

如果需要更严格的控制，可以根据需要自定义`CORS`设置。例如：

```go
router.Use(cors.New(cors.Config{
    AllowOrigins: []string{"https://example.com"}, // 允许来自特定前端域名的请求
    AllowMethods: []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
    AllowHeaders: []string{"Origin", "Content-Type", "Authorization"},
}))
```

在`cors.New`函数中，包含了对`OPTIONS`请求的判断逻辑，同时会设置状态码为`204`，并中止后续的处理流程。

除此之外，我们还可以通过在`Nginx`的配置文件中设置`proxy_pass`指令，将来自前端的请求转发到真实的后端服务地址。由于该转发过程是在服务器端完成的，浏览器只会看到自己向同源的`Nginx`服务器发起了请求，因此不会触发跨域限制。
