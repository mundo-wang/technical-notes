### 单机登录

在开发过程中，单点登录常与单机登录混淆。单机登录指同一账号在同一时间只能在有限数量的客户端保持登录状态。例如，有些系统仅允许单个`PC`端以及单个`APP`端登录，也有一些系统会限制最多同时登录`5`个客户端。

在单机登录场景中，通常需要使用有状态的`Token`进行认证。每次用户登录成功后，服务器都会为其生成新的`Token`，并将该`Token`与账号、设备类型、登录时间等信息统一存入`Redis`。可采用以下存储方式：

- 以`login:{user_id}`为`Key`，使用`ZSet`记录该用户当前所有有效`Token`与最近上线时间的时间戳。
- 以`token:{token}`为`Key`，使用`JSON`字符串保存该客户端的设备信息、登录时间，以及用户信息等数据。

在最多同时登录`5`个客户端的场景下，客户端完成登录后会生成对应的`Token`，设置`score`为当前时间戳并写入`ZSet`。后续请求在携带该`Token`时，后端会在确认其仍存在于`ZSet`的前提下同步更新对应的`score`值，否则重新登录。

当新的客户端登录成功后，会将新的`Token`写入`Redis`的`ZSet`，并检查该`ZSet`的元素数量是否已超出限制。如果超出，则根据`score`移除最近上线时间最早的`Token`，同时删除该`Token`在`Redis`中对应的`Key`保存的数据。

若需要在不同终端上分别限制登录数量，例如`PC`端与`APP`端各允许一个客户端登录，可以通过为不同终端使用独立的`Key`进行分桶处理，如`login:pc:{user_id}`与`login:app:{user_id}`。后端识别登录来源的终端类型后，会选择对应的`Key`进行操作。

在这种情况下，如果要控制客户端的登录态过期时间，需要为每个`token:{token}`设置`TTL`，例如`30`天，这样一旦`Token`超过有效期，对应的`Key`会自动过期并被`Redis`删除。

由于`ZSet`本身没有针对内部元素的`TTL`，无法自动清理过期元素，因此在新用户登录时，在判断`ZSet`元素是否超限之前，应先检查`ZSet`中的每个`Token`对应的`Key`是否存在于`Redis`，若不存在，则将该`Token`从`ZSet`中移除。同时，当客户端使用`Token`访问接口时，如果该`Token`仍在`ZSet`中，但对应的`Key`已经不存在，也应将其从`ZSet`中移除。

### 单点登录（`SSO`）

`SSO`的全称为`Single Sign-On`，即单点登录。从本质上看，`SSO`是跨系统的统一认证中心，通过集中化的身份认证与分布式的登录态传递协同运作。在`SSO`中，有`IdP`（`Identity Provider`）与`SP`（`Service Provider`）两大概念：

- `IdP`负责统一身份认证、凭证签发与会话管理，所有用户相关数据存储在这里。
- `SP`专注业务功能，仅依赖`IdP`进行用户身份校验，不自行处理登录认证。
- 用户只需在`IdP`完成一次认证，即可访问所有受信任的`SP`，无需重复登录。

在`SSO`模型中，用户与`IdP`之间建立的是全局会话，用户与单个`SP`之间建立的是局部会话。局部会话存在时，全局会话必然存在，但全局会话存在时，局部会话不一定存在。当全局会话被销毁时，所有局部会话都必须同步销毁。

单点登录的整体流程设计如下所示：

待办