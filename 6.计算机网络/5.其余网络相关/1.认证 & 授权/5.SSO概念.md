`SSO`的全称是`Single Sign-On`，即单点登录。

在开发过程中，单点登录常与单机登录混淆。单机登录指同一账号在同一时间只能在有限数量的客户端保持登录状态。例如，有些系统仅允许单个`PC`端以及单个`APP`端登录，也有一些系统会限制最多同时登录`5`个客户端。

在单机登录场景中，通常需要使用有状态的`Token`进行认证。每次用户登录成功后，服务器都会为其生成新的`Token`，并将该`Token`与账号、设备类型、登录时间等信息统一存入`Redis`。可采用以下存储方式：

- 以`login:{user_id}`为`Key`，使用`ZSet`记录该用户当前所有有效`Token`与最近上线时间的时间戳。
- 以`token:{token}`为`Key`，使用`JSON`字符串保存该客户端的设备信息、登录时间，以及用户信息等数据。

在最多同时登录`5`个客户端的场景下，客户端完成登录后会生成对应的`Token`，设置`score`为当前时间戳并写入`ZSet`。后续请求在携带该`Token`时，后端会在确认其仍存在于`ZSet`的前提下同步更新对应的`score`值，否则重新登录。

当新的客户端登录成功后，会将新的`Token`写入`Redis`的`ZSet`，并检查该`ZSet`的元素数量是否已超出限制。如果超出，则根据`score`移除最近上线时间最早的`Token`，同时删除该`Token`在`Redis`中对应的`Key`保存的数据。

若需要在不同终端上分别限制登录数量，例如`PC`端与`APP`端各允许一个客户端登录，可以通过为不同终端使用独立的`Key`进行分桶处理，如`login:pc:{user_id}`与`login:app:{user_id}`。后端识别登录来源的终端类型后，会选择对应的`Key`进行操作。

在这种情况下，需要为每个`token:{token}`设置`TTL`，例如`7`天，这样一旦`Token`超过有效期，对应的`Key`会自动过期并被`Redis`删除。由于`ZSet`本身没有`TTL`，无法自动清理过期元素，因此在新用户登录时，在判断`ZSet`元素是否超限之前，应先检查`ZSet`中的每个`Token`对应的`Key`是否存在于`Redis`，若不存在，则将该`Token`从`ZSet`中移除。同时，当客户端使用`Token`访问接口时，如果该`Token`仍在`ZSet`中，但对应的`Key`已经不存在，也应将其从`ZSet`中移除。

回到`SSO`，这是一种在多个互信系统间共享统一身份认证的机制。用户只需在一个系统中完成登录，后续系统即可复用已有的`SSO`会话或`token`等认证信息，无需再次输入账号密码。