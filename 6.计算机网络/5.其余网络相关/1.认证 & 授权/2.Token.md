`Token`是一个用于表示用户身份或访问权限的字符串。它通常被用于进行身份验证、授权或传递信息的过程中。`Token`存储在浏览器中，在发送请求时，一般放在请求的请求头中，传输到服务器，例如这样：

```sh
curl -H "Authorization: 36c60f-63013b" https://example.com/api/resource
```

`Token`的生成、存储与验证的流程如下：

1. 客户端通过用户名和密码，或者其他信息（如验证码），向服务端发送请求。
2. 服务端验证用户信息的合法性，若验证失败，返回拒绝信息。
3. 验证通过后，服务端生成一个包含用户身份信息的`Token`，并放在响应体，返回给客户端。
4. 客户端对该`Token`进行存储，通常保存在本地存储（如`LocalStorage`）中。
5. 客户端在后续的请求中，将该`Token`放入请求头，请求头名字通常为`Authorization`。
6. 服务端收到请求后，首先验证`Token`是否过期，然后对其解码，并进行签名认证，验证其有效性。
7. 验证通过后，服务端允许用户访问请求的资源或执行相应的操作，并返回对应的数据。

`Token`与`Session`的主要区别在于，`Token`不需要在服务器端存储用户的会话信息，而是通过自身的解析和验证来确认用户身份和权限，从而具备更高的可扩展性和更轻量级的特性。可以简单地理解为“时间换空间”。

在`HTTP`请求头中，`Authorization`字段通常采用如下格式：`Bearer <token>`。其中，`Bearer`意为“持有者”，用于指明`<token>`是一个无需额外身份验证的持有者令牌。只要该令牌仍然有效，客户端即可访问受保护的资源。服务端在解析`Authorization`字段时，应按照空格（`" "`）将其拆分为两部分，从中提取出实际的`token`，并据此进行后续处理。

`Token`可以分为`JWT Token`以及`OAuth 2.0 Token`两种类型，它们的具体内容如下：

### 1. `JWT`（`JSON Web Token`）相关

> `JWT`的在线生成网站：https://www.bejson.com/jwt/

`JWT`由三个部分组成，这三个部分通过点号`.`连接而成。

`Header`（头部）为 `JSON`格式，包含两部分信息，声明类型（`typ`）和使用的签名算法（`alg`）。

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

`Payload`（载荷）为 `JSON`格式，包含要传输的声明，这里一般放置用户及其他相关数据的数据信息。

```json
{
  "userName": "zhangsan",
  "dept": "safeAI",
  "userId": "330293534w"
}
```

在`Payload`中还可以设置发行者`iss`、过期时间`exp`、主题`sub`等等，其中过期时间我们一般都要设置。

`Signature`（签名）是使用`Header`中指定的签名算法，结合服务器保存的密钥`secret`，对`Header`和`Payload`进行计算得到的签名结果。相关伪代码如下所示：

```go
Signature = HMACSHA256(Base64UrlEncode(Header) + "." + Base64UrlEncode(Payload), secret)
```

`JWT`形成最终的字符串的算法，其伪代码如下所示：

```go
JwtString = Base64UrlEncode(Header) + "." + Base64UrlEncode(Payload) + "." + Base64UrlEncode(Signature)
```

`Base64UrlEncode`和`Base64`的区别是：`Base64UrlEncode`将`+`替换为`-`，`/`替换为`_`，并去掉填充字符`=`，适合在`URL`中使用。

一个`JWT`字符串的示例如下：

```sh
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
.eyJkZXB0IjoiaWt1buWQjuaPtOS8miIsInVzZXJOYW1lIjoi5byg5LiJIiwiZXhwIjoxNjY1NjMwMjc1LCJ1c2VySWQiOiIzIn0
.Oy82soyC8JGNFUzlZsZEC17Srxb6nokeBQHlonlxxkE
```

`JWT`字符串的主要长度集中在第二部分，即`Payload`经过`Base64UrlEncode`编码后的内容。因此，`JWT`的整体长度不可能是固定的，并且会随着`Payload`内容的增加而线性增长。

服务端解析`JWT`通常需要执行以下步骤：

1. 分割`JWT`：将`JWT`字符串按照`.`进行分割，分成`Header`、`Payload`和`Signature`三个部分。
2. `Base64`解码：对`Header`和`Payload`部分进行`Base64`解码，获取原始的`JSON`格式数据。
3. 验证签名：使用相同的编码算法和密钥，对解码后的`Header`和`Payload`重新生成签名，并与`JWT`中的`Signature`进行比较。若重新生成的签名与`JWT`中的`Signature`相同，则说明`JWT`未被篡改，服务端可信任其中的用户数据。

### 2. `OAuth 2.0 Token`相关

在`OAuth 2.0`认证框架中，主要涉及两种令牌：`AccessToken`（访问令牌）和`RefreshToken`（刷新令牌），它们的作用如下：

- `AccessToken`：用于访问受保护资源的凭证，有效期通常较短，一般在`5`分钟到`1`小时之间。

- `RefreshToken`：用于在访问令牌过期后获取新的访问令牌，其生命周期通常更长，一般在`7`天到`30`天之间。

`OAuth 2.0`的认证过程包括以下几个步骤：

1. 同步用户信息：资源服务器将平台侧的用户信息同步至认证服务器，用于后续的用户身份校验与令牌颁发。
2. 申请授权码：前端向认证服务器发起授权请求，用户完成身份验证后，认证服务器返回授权码。
3. 获取令牌：前端传递授权码到后端，后端向认证服务器申请访问令牌和刷新令牌，并返回访问令牌给前端。
4. 访问资源：前端携带访问令牌，向资源服务器请求访问受保护的数据与服务，授权的工作由资源服务器完成。
5. 刷新访问令牌：如果资源服务器发现访问令牌过期，使用刷新令牌向认证服务器申请新的访问令牌。

`JWT`是一种无状态令牌。一旦签发，服务器通常不会主动使其失效，而是依赖`exp`过期时间来控制有效期。

由于这一设计特性，`JWT`天然不支持用户主动下线或服务端强制下线。也就是说，在`JWT`签发完成后，即使用户已退出登录、账号被封禁或密码被修改，之前签发的`JWT`在`exp`到期之前仍然有效。虽然客户端可以删除本地存储的`JWT`，但如果该令牌已被第三方截获，在过期之前仍可用于访问受保护的资源。

从服务端视角看，无法单方面使某个已签发的`JWT`立即失效，除非额外引入黑名单、`jti`校验、频繁轮换密钥或缩短令牌有效期等机制。但这些方案都要求服务端维护额外状态，实质上破坏了`JWT`完全无状态的设计初衷。

相较而言，`OAuth 2.0`的`AccessToken`通常具有较短的有效期。令牌过期后，客户端需要通过`RefreshToken`向认证服务器申请新的`AccessToken`。当用户主动下线或服务端执行强制下线时，认证服务器会删除对应的`RefreshToken`，客户端同时清除本地存储的`AccessToken`。即使访问令牌被第三方截获，由于其有效期较短，也能在较大程度上降低被滥用的风险。

如果认证服务器发现传入的`RefreshToken`已过期，则会拒绝刷新`AccessToken`，并返回相应的错误信息。此时，用户需要重新走登录认证流程，以获取新的`AccessToken`和`RefreshToken`。

`AccessToken`通常由前端进行存储，用于在调用受保护接口时携带身份凭证。而`RefreshToken`由于具有更长的有效期，一旦泄露可能带来更大风险，因此由后端负责存储和管理，通常持久化在数据库中。我们可以设计如下的`Token`管理表：

```sql
CREATE TABLE `user_token` (
    `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '主键ID',
    `user_id` BIGINT NOT NULL COMMENT '用户ID',
    `access_token` VARCHAR(512) NOT NULL COMMENT '访问Token',
    `refresh_token` VARCHAR(512) NOT NULL COMMENT '刷新Token',
    `at_expired_at` DATETIME NOT NULL COMMENT '访问Token过期时间',
    `rt_expired_at` DATETIME NOT NULL COMMENT '刷新Token过期时间',
    `device_id` VARCHAR(255) NOT NULL DEFAULT '' COMMENT '设备ID，支持多设备登录',
    `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    `updated_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (`id`)
) COMMENT='用户Token表';
```

当用户首次通过前端发起请求并完成`OAuth 2.0`授权流程后，系统会获取`AccessToken`、`RefreshToken`及其过期时间。后端将这些信息与用户标识一并写入`user_token`表，用于后续身份验证和会话管理。

之后，前端在每次请求中都会携带`AccessToken`访问业务系统。后端接收到请求后，会根据该`AccessToken`查询`user_token`表。

如果查询到记录且`AccessToken`未过期，说明用户登录状态仍然有效，系统会根据`user_id`确定用户角色，并授予相应权限。

如果`AccessToken`已过期，后端将继续检查对应的`RefreshToken`是否过期：

- 若`RefreshToken`未过期，后端会凭刷新令牌向认证服务器申请新的`AccessToken`，更新`user_token`表中的访问令牌及其过期时间，并将刷新后的`AccessToken`返回给前端，供后续请求携带使用。
- 若`RefreshToken`也已过期，说明用户会话已失效，系统将删除`user_token`表中对应的记录，并跳转至认证服务器的登录页面，引导用户重新完成认证流程。认证服务器颁发新的令牌后，向`user_token`表写入新的令牌信息。

用户手动登出系统时，后端应根据传入的`AccessToken`删除`user_token`表中对应记录，并调用认证服务器接口，移除该`AccessToken`及对应的`RefreshToken`，确保认证状态被清除。用户后续需重新登录获取新的`AccessToken`和`RefreshToken`。

`OAuth 2.0`认证流程的时序图如下所示：

<img src="image/image-20250923145256216.png" alt="image-20250923145256216" style="zoom:70%;" />

`OAuth 2.0`认证流程的时序图，其`PlantUML`代码如下所示：

```scss
@startuml
actor 用户
participant 前端
participant 后端 as BE
participant 认证服务器 as AS
database "user_token表" as DB

== 用户首次登录系统 ==
用户 -> 前端: 发起登录请求
前端 -> AS: 请求授权码
AS -> 用户: 跳转登录页，请求用户进行身份验证
用户 --> AS : 输入用户登录信息
AS --> 前端: 用户身份验证通过，返回授权码
前端 -> BE: 携带授权码，请求后端登录接口
BE -> AS: 根据授权码，请求获取AccessToken和RefreshToken
AS --> BE: 返回AccessToken、RefreshToken，以及它们的过期时间
BE -> DB: 保存user_id、AccessToken、RefreshToken、过期时间等信息
BE --> 前端: 返回AccessToken

== 用户使用AccessToken认证 ==
用户 -> 前端: 发起访问请求
前端 -> BE: 携带AccessToken请求后端接口
BE -> DB: 查询AccessToken
alt AccessToken未过期
    BE -> BE : 执行接口业务逻辑
    BE --> 前端: 返回接口数据
else AccessToken 已过期
    BE -> DB: 校验RefreshToken是否过期
    alt RefreshToken 未过期
        BE -> AS: 使用RefreshToken刷新AccessToken
        AS --> BE: 返回新的 AccessToken
        BE -> DB: 更新AccessToken与过期时间
        BE -> BE : 执行接口业务逻辑
        BE --> 前端: 返回接口数据与新的AccessToken
    else RefreshToken 已过期
        BE -> DB: 删除对应user_token表记录
        BE -> 用户: 跳转登录页，要求用户重新登录
    end
end

== 用户登出 ==
用户 -> 前端: 发起退出登录请求
前端 -> BE: 携带AccessToken请求登出
BE -> DB: 删除对应user_token表记录
BE -> AS: 调用接口移除对应的AccessToken和RefreshToken
BE --> 前端: 返回登出成功
@enduml
```

