`UDP`（`User Datagram Protocol`，用户数据报协议）是`TCP/IP`协议族中传输层的另一种协议，与`TCP`相比，`UDP`提供的是无连接、不可靠、面向报文的通信服务。它的设计理念是尽可能简单、开销小、效率高，适用于对实时性要求高、对可靠性要求低的场景。

`UDP`协议的特点如下：

1. 无连接：在数据传输前不需要建立连接，发送数据时直接将报文发给目标，无需进行握手过程。
2. 不可靠传输：`UDP`不保证数据一定能送达，不保证顺序，也不做重传，数据可能会丢失、重复、乱序。
3. 面向报文：发送方将数据封装为独立的报文（`Datagram`），接收方一次性接收整个报文，报文之间保持边界。
4. 开销小、效率高：头部开销小，仅`8`字节，不需要维护连接状态，适合高并发、短连接的应用场景。
5. 支持广播和多播：`UDP`支持广播（`Broadcast`）和多播（`Multicast`），适合局域网中的消息广播。

`UDP`的典型应用场景包括：实时音视频通信（如`VoIP`、在线视频会议）、实时在线游戏、`DNS`查询、`DHCP`协议、简单的物联网设备通信、流媒体传输（如`RTSP`、`RTP`）等。这些应用通常更注重“速度”而不是“可靠性”，即使偶尔丢一些数据也能容忍。

例如在使用微信进行视频通话时，如果遇到网络质量较差的情况（如`Wi-Fi`信号弱、带宽被占满、延迟高、抖动严重），就容易发生`UDP`报文丢失。由于`UDP`不具备重传机制，数据一旦丢失就无法恢复，和具备重传机制的`TCP`不同。

此外，视频编码器本身也不会对丢失的帧进行重发。如果丢失的是关键帧（`I`帧），播放器可能需要等到下一帧关键帧才能继续解码播放，导致画面出现“冻结”；如果丢的是普通帧（`P`帧或`B`帧），画面可能会出现花屏或跳帧现象，但通常还能继续播放。

这些丢包现象会导致多种明显的用户体验问题，例如画面突然卡住不再刷新，图像变得模糊或出现色块，声音播放断断续续，音画不同步，甚至可能出现短暂的黑屏或花屏等现象；如果丢包过于严重，视频通话可能会被系统直接中断并提示“视频已中断”。

`UDP`之所以被定义为“不可靠”的协议，是因为它没有实现以下功能：

1. 不建立连接，即通信前无需经过三次握手；
2. 不确认接收，即没有`ACK`机制；
3. 不重传丢失的数据；
4. 不保证报文顺序，先发送的报文段可能后到达；
5. 不具备流量控制和拥塞控制机制。

正因如此，`UDP`无法确保数据的完整性、顺序性以及准确送达。它的设计理念是尽可能快速地将数据发送出去，而不关心数据是否被成功接收、是否丢失或乱序。

虽然`UDP`不可靠，但它的“轻量”和“快速”恰好满足了某些场景的需求，如果应用层自己实现了可靠性机制（如`QUIC`、`RTP`），如果对数据完整性要求低但对实时性要求高（如音视频），如果一次传输的数据很短，开销不值得使用`TCP`（如`DNS`）。

比如在视频会议中，偶尔丢失一帧视频或一段音频不影响整体体验，但如果等确认重传，会带来延迟，体验反而变差。

那么为什么还需要`UDP`呢？因为在实时通信场景中，及时送达比准确送达更重要。如果用了`TCP`，丢包时需要重传数据，造成更长时间延迟，导致“声音晚几秒”、“画面卡成PPT”。而`UDP`即使偶尔丢点数据，也能维持实时性，整体体验更流畅。所以，轻微的卡顿是`UDP`机制设计中的一种“可接受成本”。

虽然`UDP`不可靠，但其“轻量”“快速”的特性非常适合对实时性要求高的场景。相比`TCP`的连接建立、确认和重传机制，`UDP`能更快发送数据，避免因等待重传带来的延迟。例如在视频会议中，偶尔丢一帧不会影响整体体验，但若因重传导致延迟，反而会造成更严重的音画不同步与卡顿。此外，像`QUIC`、`RTP`等协议可在`UDP`之上实现可靠性机制，使其既快又稳。因此，在实时通信中，及时送达往往比准确送达更重要，轻微的丢包是可接受的成本权衡。

`UDP`与`TCP`的对比如下所示：

| 特性           | `TCP`                        | `UDP`               |
| -------------- | ---------------------------- | ------------------- |
| 连接类型       | 面向连接                     | 无连接              |
| 可靠性         | 可靠传输（确认、重传、排序） | 不可靠传输          |
| 传输方式       | 字节流（无边界）             | 报文（有边界）      |
| 首部长度       | 最少`20`字节，最多`60`字节   | 固定`8`字节         |
| 是否有拥塞控制 | 有                           | 无                  |
| 是否支持广播   | 不支持                       | 支持                |
| 传输效率       | 较低（可靠性带来开销）       | 高（简单直接）      |
| 适用场景       | 文件传输、邮件、网页等       | 视频、语音、`DNS`等 |

“面向报文”和“面向字节流”是`UDP`和`TCP`最本质的区别之一。

假设你使用`TCP`和`UDP`分别连续发送两段数据：

- 第一次发送：`"Hello"`。
- 第二次发送：`"World"`。

由于`TCP`是面向字节流的协议，接收方接收数据时不会自动按发送时的次数或边界来划分数据，因此可能出现多种情况：

- 一次性收到完整数据：`"HelloWorld"`。
- 分两次收到不规则片段：`"Hel"`和`"loWorld"`。
- 分三次收到更小的片段：`"He"`、`"llo"`、`"World"`。

也就是说，接收方接收到的是一串连续的字节，无法知道这些字节原本是按几次发送的，也不知道每次发送的边界在哪里。

由于`UDP`是面向报文的协议，每次发送的数据都会作为一个完整报文传输，接收方也会一次接收一个完整报文，因此结果始终是：

- 第一次收到：`"Hello"`。
- 第二次收到：`"World"`。

也就是说，接收方收到的数据和发送方每次发送的内容严格对应，边界不会被拆分、合并或重组。

`UDP`协议的报文格式非常简单，其头部长度只有固定`8`字节：

| 字段名             | 长度（位） | 描述                                  |
| ------------------ | ---------- | ------------------------------------- |
| `Source Port`      | `16`       | 源端口号，标识发送端应用程序          |
| `Destination Port` | `16`       | 目标端口号，标识接收端应用程序        |
| `Length`           | `16`       | 报文总长度（包括`UDP`头部和数据部分） |
| `Checksum`         | `16`       | 校验和（包括伪头部、`UDP`头、数据）   |

这部分内容这里不做展开讲解。
