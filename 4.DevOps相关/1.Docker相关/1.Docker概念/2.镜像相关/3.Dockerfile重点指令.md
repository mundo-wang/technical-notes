在上一节中，讲了一下`Dockerfile`的常用关键字，但是只是粗略说明了用途。这一节详细讲一下重点的那八个关键字。

### 1. `FROM`

`FROM`用于指定基础镜像，基础镜像是构建新镜像的起点，包含了操作系统以及一些预安装的软件包。`FROM`指令后面跟着的是镜像的名称以及标签，例如`FROM ubuntu:20.04`，标签也可以为`latest`。`Docker`构建镜像时，会下载并指定使用的基础镜像，然后根据`Dockerfile`的内容，在其上添加更多层，形成自己的镜像。

基础镜像有以下几种类型：

1. 官方基础镜像：由`Docker`官方提供的镜像，通常提供了最基本的操作系统环境。常见的官方基础镜像包括：`ubuntu`、`debian`、`centos`、`alpine`（轻量级`Linux`镜像）。
2. 语言特定基础镜像：针对特定编程语言提供了优化的基础镜像，通常包含了该语言或应用程序的运行时环境和工具链。例如`python`、`node`、`openjdk`、`golang`等等。
3. 应用程序特定基础镜像：针对特定应用程序或服务的基础镜像，通常包含了该应用程序的运行时环境和依赖。例如：`nginx`、`mysql`、`postgres`、`redis`等等。
4. 自定义基础镜像：也就是其他使用`Dockerfile`打出的镜像，可以更好地控制镜像的内容和大小，以满足特定的应用场景需求。

### 2. `ENV`

`ENV`用于设置环境变量。环境变量是一种在容器内部存储配置信息、运行时参数等的机制，可以在`Dockerfile`里预先设置，也可以在启动容器时使用`-e`参数，或者`docker-compose.yml`文件中的`environment`关键字来设置。

在`Dockerfile`中设置的方式如下所示：

```dockerfile
ENV PORT=8080 
ENV ENVIRONMENT=production
```

在容器运行时，这些环境变量可以被应用程序或服务读取并使用。例如在`Go`语言中可以使用`os.GetEnv()`来获取对应环境变量值。

### 3. `SHELL`

`SHELL`用于指定`shell`解释器，指定在后续的`RUN`、`CMD`等指令所使用的`shell`解释器。默认情况下是`/bin/sh -c`。

这个地方所指定的，也是后续使用`docker exec`进入容器时，末尾跟的指令。

下面是一个简单的`SHELL`指令的示例：

```dockerfile
SHELL ["/bin/bash", "-c"]
```

这个`-c`参数表示使用`bash`解释器执行的是一个命令字符串，允许在命令行上直接执行一个命令，而不必编写一个脚本文件。

### 4. `WORKDIR`

`WORKDIR`用于设置工作目录。工作目录就是指容器内部执行时的默认目录，在后续的`COPY`、`RUN`、`CMD`等指令中，如果没有指定绝对路径，则相对于这个工作目录执行。一个简单的`WORKDIR`命令示例：

```dockerfile
WORKDIR /app
```

我们使用`docker exec`进入容器时，默认进入的就是`WORKDIR`所指定的目录。

在多个`WORKDIR`指令出现时，后面的指令会覆盖前面的指令，即以最后一个`WORKDIR`指定的目录作为工作目录。如果不设置`WORKDIR`，则默认为根目录`/`。

### 5. `COPY`

`COPY`用于将文件或目录从构建环境（宿主机文件系统）复制到容器的文件系统中，它的语法是：

```
COPY <源路径>... <目标路径>
```

其中源路径和目标路径定义如下：

- 源路径：宿主机内希望复制的文件或目录的位置，可以为绝对路径，也可以为相对路径。相对路径是相对于`Docker`构建上下文（通常是 `Dockerfile`所在的目录）的位置。源路径可以为多个。
- 目标路径：容器内的目录路径，可以为绝对路径，也可以为相对路径。相对路径为相对于`WORKDIR`指定的路径。

如果源文件或目录的路径在构建环境中不存在，`COPY`命令将会失败并导致构建过程中断。如果目标路径不存在，`Docker`会自动创建它。`COPY`无法把容器的文件或目录复制到宿主机上。

如果是构建环境的目录复制到容器，其实是把该目录中的所有子目录和文件复制到容器对应的路径下，例如：

```dockerfile
COPY /etc/kafka-consumer/conf /app/kafka-consumer/config
```

实际是把构建环境`conf`目录下的所有内容复制到容器的`config`目录下。

在多阶段构建中，可以在后面的阶段使用`--from=`来指定前面阶段，将前面阶段的文件或目录复制到后面阶段。指定前面阶段的路径时，依然可以使用绝对路径（容器路径）和相对路径，相对路径为相对于`WORKDIR`指定的路径。例如：

```dockerfile
COPY --from=build-stage /app/i18n /app/i18n
```

### 6. `ADD`

`ADD`与`COPY`命令类似，也是将文件或目录从构建环境复制到容器，但除了复制功能外，`ADD`还能自动解压缩文件与远程文件下载。

`ADD`指令的语法格式与`COPY`相同，下面举例解压缩和远程下载的命令：

```dockerfile
ADD app.tar.gz /app/software
ADD http://example.com/file.tar.gz /app/software
```

命令讲解如下：

- 第一条指令会将`app.tar.gz`文件解压缩，并将解压后的文件复制到容器内的`/app/software`目录下。

- 第二条指令会从指定`URL`下载`file.tar.gz`文件并复制到容器内的`/app/software`目录下。

### 7. `RUN`

`RUN`用于在镜像构建过程中执行命令，例如安装软件包（`apt-get`、`yum`、`apk`等）、运行编译器（`go build`、`javac`等），以及一些其他命令，如`go mod`、`./`命令等。

一个`RUN`指令可以执行多条命令，它们之间使用`&&`进行连接，表示前一条命令执行成功再执行下一条命令：

```dockerfile
RUN command1 && \
    command2 && \
    command3
```

或者也可以使用分号`;`进行分隔，表示无论前一条命令执行是否成功，后一条命令都会执行：

```dockerfile
RUN command1 ; \
    command2 ; \
    command3
```

在执行`RUN`指令时，`Docker`会启动一个临时容器，在其中执行指定的命令，并根据执行结果生成新的镜像层。每个`RUN`指令都会创建一个新的镜像层，因此尽量将多个相关的命令合并到一个`RUN`指令中，以减少镜像的层数，从而减小镜像的大小。

### 8. `CMD`

`CMD`命令用于指定容器启动时默认执行的命令，每个`Dockerfile`只能有一个`CMD`指令，如果有多个，则只有最后一个会生效。

`CMD` 指令有两种形式：`exec`格式和`shell`格式。以启动`Go`语言容器为例，`exec`格式就是`CMD ["python", "app.py"]`，`shell`格式就是`CMD python app.py`。二者的区别就是`exec`模式不会启用额外的`shell`进程，即前者相当于直接执行`python app.py`，而后者相当于执行了`/bin/sh -c "python app.py"`（按照`SHELL`指定）。所以需要尽可能去使用`exec`格式，除非有特别的需要。

如果`Dockerfile`中没有`CMD`指令，当容器启动时，会使用基础镜像中预设的默认启动命令`/bin/sh -c`（按照`SHELL`指定），由于没有提供任何命令或参数，该`shell`进程通常会立即退出，导致容器也随即退出。所以，`CMD`指令是必要存在的。