在临时切换分支或中断工作时，可以使用`git stash`来临时存储当前工作目录中的更改。

#### 1. 临时存储修改但未`commit`的内容

```bash
git stash
```

这样会生成一条格式为：`stash@{0}: WIP on <当前分支名>: <当前HEAD提交ID缩写> <当前HEAD提交信息>`的`stash`记录。

#### 2. 临时存储修改但未`commit`的内容，并带`message`说明

```bash
git stash save "stash message"
```

这样会生成一条格式为：`stash@{0}: On <当前分支名>: <stash message>`的`stash`记录。

最新创建的`stash`记录编号为`stash@{0}`，已有的`stash`记录编号依次递增。

#### 3. 列出所有存在的`stash`

```bash
git stash list
```

#### 4. 查看指定`stash`的修改涉及到的文件

```bash
git stash show stash@{1}
```

#### 5. 恢复最后一次`stash`并从`list`中删除

```bash
git stash pop
```

这相当于先后执行了`git stash apply stash@{0}`和`git stash drop stash@{0}`的组合操作。

#### 6. 应用某一次的`stash`

```bash
git stash apply stash@{1}
```

#### 7. 删除某一个`stash`

```bash
git stash drop stash@{1}
```

需要注意的是，如果你删除了`stash{1}`，原本的`stash{2}`会自动变为新的`stash{1}`，其后的每个`stash`也都会依次向前移动一位。因此，在每次执行删除操作前，都要先使用`git stash list`查看当前的`stash`列表，确保删除的是目标项。

#### 8. 清空`stash`列表

```bash
git stash clear
```

#### 9. 在`PowerShell`中的注意事项

在`PowerShell`中，`@`和`{}`是元字符，需要用引号把整个参数包裹起来，例如：

```bash
git stash show 'stash@{0}'
git stash apply 'stash@{0}'
```
