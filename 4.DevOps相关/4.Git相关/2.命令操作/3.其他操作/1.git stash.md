在临时切换分支或中断工作时，可以使用`git stash`来临时存储当前工作目录中的更改。

#### 1. 临时存储修改但未`commit`的内容

```bash
git stash
```

这样会生成一条格式为：`stash@{0}: WIP on <当前分支名>: <当前HEAD提交ID缩写> <当前HEAD提交信息>`的`stash`记录。

#### 2. 临时存储修改但未`commit`的内容，并带`message`说明

```bash
git stash save "stash message"
```

这样会生成一条格式为：`stash@{0}: On <当前分支名>: <stash message>`的`stash`记录。

最新创建的`stash`记录编号为`stash@{0}`，已有的`stash`记录编号依次递增。

#### 3. 列出所有存在的`stash`

```bash
git stash list
```

#### 4. 查看指定`stash`的修改涉及到的文件

```bash
git stash show stash@{1}
```

#### 5. 恢复最后一次`stash`并从`list`中删除

```bash
git stash pop
```

这相当于先后执行了`git stash apply stash@{0}`和`git stash drop stash@{0}`的组合操作。

#### 6. 应用某一次的`stash`

```bash
git stash apply stash@{1}
```

在使用`git stash pop`或`git stash apply`时，如果本地工作区存在未提交的修改，可能会导致代码冲突：

```sh
error: Your local changes to the following files would be overwritten by merge:
        src/main/java/com/ctsi/pubinfo/iot/service/impl/AiDingTalkNotifyServiceImpl.java
Please commit your changes or stash them before you merge.
Aborting
```

需要注意的是，`stash`在判断冲突时与`Git`的常规冲突处理方式有所不同。`Git`的冲突发生在对同一文件的相同部分进行不同修改时，而`stash`只要修改的是同一个文件，不论是否为同一区域，都会触发冲突。

如果在应用`stash`时发生冲突，`Git`不会允许你直接解决冲突，而是恢复到没有使用`stash`的状态，要求你先处理本地工作区的修改（例如提交或`stash`），然后才能重新应用该`stash`。

#### 7. 删除某一个`stash`

```bash
git stash drop stash@{1}
```

需要注意的是，如果你删除了`stash{1}`，原本的`stash{2}`会自动变为新的`stash{1}`，其后的每个`stash`也都会依次向前移动一位。因此，在每次执行删除操作前，都要先使用`git stash list`查看当前的`stash`列表，确保删除的是目标项。

#### 8. 清空`stash`列表

```bash
git stash clear
```

#### 9. 在`PowerShell`中的注意事项

在`PowerShell`中，`@`和`{}`是元字符，需要用引号把整个参数包裹起来，例如：

```bash
git stash show 'stash@{0}'
git stash apply 'stash@{0}'
```
