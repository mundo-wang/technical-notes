在临时切换分支或中断工作时，可以使用`git stash`来临时存储当前工作目录中的更改。

#### 1. 临时存储修改但未`commit`的内容

```bash
git stash
```

这样会生成一条格式为：`stash@{0}: WIP on <当前分支名>: <当前HEAD提交ID缩写> <当前HEAD提交信息>`的`stash`记录。

#### 2. 临时存储修改但未`commit`的内容，并带`message`说明

```bash
git stash save "stash message"
```

这样会生成一条格式为：`stash@{0}: On <当前分支名>: <stash message>`的`stash`记录。

最新创建的`stash`记录编号为`stash@{0}`，已有的`stash`记录编号依次递增。

#### 3. 列出所有存在的`stash`

```bash
git stash list
```

#### 4. 查看指定`stash`的修改涉及到的文件

```bash
git stash show stash@{1}
```

如果不指定任何`stash`，该命令会默认执行`stash@{0}`。

#### 5. 恢复最后一次`stash`并从`list`中删除

```bash
git stash pop
```

这相当于先后执行了`git stash apply stash@{0}`和`git stash drop stash@{0}`的组合操作。

#### 6. 应用某一次的`stash`

```bash
git stash apply stash@{1}
```

如果不指定任何`stash`，该命令会默认执行`stash@{0}`。

在使用`git stash pop`或`git stash apply`时，如果本地工作区存在未提交的修改，可能会导致代码冲突：

```sh
error: Your local changes to the following files would be overwritten by merge:
        src/main/java/com/ctsi/pubinfo/iot/service/impl/AiDingTalkNotifyServiceImpl.java
Please commit your changes or stash them before you merge.
Aborting
```

当工作区存在未提交的修改时，`stash`判断冲突的方式与常规的`Git`冲突处理略有不同。通常情况下，`Git`只有在对同一文件的相同位置进行了不同的修改，才会引发冲突；而`stash`只要涉及同一个文件的改动，无论修改区域是否重叠，都会触发冲突。

在这种情况下，如果发生冲突，`Git`不会让你像处理普通冲突那样直接解决。相反，它会撤销此次`stash apply`操作，将工作区恢复到应用`stash`之前的状态，并提示你先处理当前工作区的改动（比如提交、再次`stash`或还原修改），然后再重新应用该`stash`。

但如果冲突发生在`stash`内容与已`commit`的代码之间，此时`Git`的处理方式就与常规冲突相同：会保留冲突标记，并允许你手动解决冲突后继续操作。

#### 7. 删除某一个`stash`

```bash
git stash drop stash@{1}
```

如果不指定任何`stash`，该命令会默认执行`stash@{0}`。

需要注意的是，如果你删除了`stash{1}`，原本的`stash{2}`会自动变为新的`stash{1}`，其后的每个`stash`也都会依次向前移动一位。因此，在每次执行删除操作前，都要先使用`git stash list`查看当前的`stash`列表，确保删除的是目标项。

#### 8. 清空`stash`列表

```bash
git stash clear
```

#### 9. 在`PowerShell`中的注意事项

在`PowerShell`中，`@`和`{}`是元字符，需要用引号把整个参数包裹起来，例如：

```bash
git stash show 'stash@{0}'
git stash apply 'stash@{0}'
```
