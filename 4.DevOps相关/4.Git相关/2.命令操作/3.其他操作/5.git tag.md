`git tag`是一个用于为`Git`仓库中的某一特定提交（`commit`）创建标签（`Tag`）的命令，通常用于标记版本或里程碑，例如发布版本`v1.0.0`。它可以为提交添加一个易于识别的名字。

`Git`的标签分为两种类型：轻量标签和附注标签。一个标签关联一次`Git`提交。

#### 1. 轻量标签（`Lightweight Tag`）

创建轻量标签的指令非常简单，如下所示：

```sh
git tag <tagname>
```

这样可以把名为`<tagname>`的轻量标签添加到当前分支的最新提交。轻量标签是指向某次提交的简单指针，不包含额外的元数据，如作者、日期、标签说明等，创建简单，适合临时性或非正式标记。

#### 2. 附注标签（`Annotated Tag`）

创建附注标签的指令如下所示：

```sh
git tag -a <tagname> -m "Tag message"
```

这样可以把名为`<tagname>`，标签信息为`Tag message`的附注标签添加到当前分支的最新提交。附注标签是一个完整的`Git`对象，包含附加信息，如作者、日期、标签说明等。标签内容会存储在`Git`历史中，适合正式发布版本。

#### 3. 查看标签

查看当前仓库中的所有标签：

```sh
git tag
```

使用模式匹配标签，例如查看`v1.`开头的标签：

```sh
git tag -l "v1.*"
```

#### 4. 为指定提交添加标签

如果我们希望给指定的某次提交添加标签，而不是当前分支的最新提交，可以使用以下指令：

```sh
git tag <tagname> <commit-hash>
```

这样添加的标签是一个轻量标签，如果想添加一个附注标签，可以使用以下命令：

```sh
git tag -a <tagname> <commit-hash> -m "Tag message"
```

#### 5. 查看标签详情

查看标签对应的相关详细信息，命令如下：

```sh
git show <tagname>
```

如果只想查看`tag`对应的`commit`信息，可以使用如下命令：

```
git show --no-patch <tagname>
```

#### 6. 推送标签

默认情况下，标签不会自动推送到远程仓库，需要手动推送，推送标签的完整流程如下所示。

首先进行代码修改，将代码的变更提交到`Git`的本地仓库中，并推送到远程仓库：

```sh
git add .
git commit -m "Your commit message"
git push
```

接下来，为这次提交创建一个标签，可以是轻量标签或者附注标签：

```sh
git tag -a v1.0.0 -m "Release version 1.0.0"
```

这样，标签已成功关联到之前的提交，现在可以将该标签推送到远程仓库：

```sh
git push origin v1.0.0
```

如果有多个标签可以一次性推送：

```sh
git push --tags
git push --follow-tags # 只推送附注标签
```

需要注意的是，标签推送到远程仓库后，在`Go`项目中执行`go get -u`或`go get ...@latest`命令时，并不会立即读取到该标签。通常需要等待`10`至`20`分钟后，才能获取到这一更新。

#### 7. 删除标签

删除本地标签：

```sh
git tag -d <tagname>
```

删除远程标签（不可省略`origin`）：

```
git push origin --delete <tagname>
```

#### 8. 拉取远程仓库标签

拉取远程仓库所有标签：

```sh
git fetch --tags
```

该命令仅会更新标签和引用，不会影响本地分支的代码。

拉取特定的标签：

```sh
git fetch origin tag <tagname>
```

拉取远程分支代码以及关联的标签：

```sh
git pull --tags
```

该命令相当于先执行一次`git pull`，并仅在拉取的提交关联有标签时，将这些标签同步到本地。

#### 9. 标签的使用

基于某个标签创建新分支：

```sh
git switch -c <新分支名> <标签名>
```

克隆特定标签的代码：

```sh
git clone --branch <标签名> <仓库地址>
```

回滚到特定标签对应的代码状态：

```
git reset --hard <标签名>
```

这种方式会重置当前分支的代码状态，谨慎使用。

#### 10. 语义化版本控制

语义化版本控制（`Semantic Versioning`，简称`SemVer`）是一种版本命名规范，旨在帮助开发者管理软件版本并传达版本变更的影响。语义化版本由三个数字部分组成：

```
MAJOR.MINOR.PATCH
```

这三个部分所代表的版本变更情况如下所示：

| 版本类型            | 变更类型                   | 影响                         | 示例                |
| ------------------- | -------------------------- | ---------------------------- | ------------------- |
| `Major`（主版本）   | 破坏性变更（不兼容旧代码） | 需要手动修改代码适配新版本   | `v1.9.0` → `v2.0.0` |
| `Minor`（次版本）   | 新功能（兼容旧代码）       | 旧代码可用，但可以使用新功能 | `v1.2.3` → `v1.3.0` |
| `Patch`（补丁版本） | `Bug`修复（完全兼容）      | 旧代码无影响，只是更稳定     | `v1.2.3` → `v1.2.4` |

例如下面的版本号更新说明：

| 版本号  | 说明                            |
| ------- | ------------------------------- |
| `1.0.0` | 初始稳定版本                    |
| `1.1.0` | 添加新功能，但仍然兼容`1.0.0`   |
| `1.1.1` | 修复`1.1.0`中的问题，不改变功能 |
| `2.0.0` | 引入破坏性变更，不兼容`1.x.x`   |

如果是未正式发布的版本，可以在`PATCH`后加上`-`和先行版本标识，例如：`1.0.0-alpha.1`、`1.0.0-beta.2`、`1.0.0-rc.3`。

- `alpha`：内部测试版，功能可能不完整，可能有较多`BUG`。
- `beta`：公开测试版，功能基本完整，但可能仍然有问题。
- `rc`（`release candidate`）：候选发布版，接近正式发布，可能还有一些小修复。

语义化版本比较时，按照`MAJOR` > `MINOR` > `PATCH` > 先行版本的顺序进行比较，先行版本中`rc` > `beta` > `alpha`。

在语义化版本控制中，主版本可以从`0`开始，表示处于初始开发阶段，接口尚不稳定。直到发布`v1.0.0`，才意味着模块进入稳定阶段，开始遵循兼容性承诺。也就是说，正式稳定版本一般从`1`开始，而`v0`更多用于试验性开发。
