例如有一个简单的`Go`项目，目录结构如下：

```scss
myapp/
├── main.go
├── go.mod
├── Makefile
```

`main.go`内容如下所示：

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, Makefile!")
}
```

`Makefile`内容如下所示：

```makefile
APP_NAME=myapp

.PHONY: clean build run

build:
	go build -o $(APP_NAME) main.go

run: build
	./$(APP_NAME)

clean:
	rm -f $(APP_NAME)

myapp: main.go
	go build -o $(APP_NAME) main.go
```

在这段`Makefile`中，`APP_NAME=myapp`是一个变量定义，格式为`VAR_NAME=VALUE`。在后续的代码中，可以通过`$(VAR_NAME)`引用该变量的值，例如`$(APP_NAME)`的值为`myapp`。

`build`、`run`、`clean`和`myapp`都是`Makefile`中的目标（`target`），目标可以是执行目录下存在的文件，也可以是自定义的动作名称。在`Makefile`文件中，目标行的格式为：

```makefile
target: dependency
	command
```

> 在`Makefile`中，目标行下一行的命令必须用一个`tab`字符开头，使用空格缩进是不允许的，会导致`make`命令报错。

使用`make <target>`可以执行指定目标下的`command`。如果直接运行`make`而不指定目标，`make`会默认执行文件中的第一个目标。`make`命令默认会查找名为`Makefile`或`makefile`的文件，因此项目中的构建文件一般使用这两个名字之一。

执行`make <target>`时，`make`会先检测执行目录下是否存在与`target`同名的文件。如果文件已存在，`make`会认为目标已完成，不再执行命令。为了避免自定义目标与文件名冲突，可以使用`.PHONY`声明其为伪目标：

```makefile
.PHONY: clean build run
```

这表示列出的目标不是实际文件，而是纯粹的命令集合，`make`在执行这些目标时，不会检查文件是否存在。

`dependency`是可选的，用于指定该目标所依赖的其他目标。例如，`run: build`表示执行`make run`时，会先执行`build`目标的命令，然后再执行`run`目标的命令。类似地，`myapp: main.go`表示执行`make myapp`时，`make`会先检查`main.go`是否被修改：如果已修改，则执行目标命令；如果未修改，则检查`myapp`文件是否存在，存在则跳过命令执行，不存在则执行命令。

使用`Makefile`可以显著简化日常构建流程，无需手动输入复杂的编译或运行命令。只需执行相应的`make`命令，即可完成构建、运行或清理操作，从而实现项目构建与运行的自动化和标准化。